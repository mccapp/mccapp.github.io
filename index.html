<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>nearby.ren</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
<meta property="og:type" content="website">
<meta property="og:title" content="nearby.ren">
<meta property="og:url" content="http://b.nearby.ren/index.html">
<meta property="og:site_name" content="nearby.ren">
<meta property="og:description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nearby.ren">
<meta name="twitter:description" content="nearby, 移动开发, 用户体验, 设计, Java, JavaWeb, Go">
    

    
        <link rel="alternate" href="/atom.xml" title="nearby.ren" type="application/atom+xml">
    

    
        <link rel="icon" href="/css/images/super.png# path to favicon">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">nearby.ren</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">目录</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.png">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">目录</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png">
            <h2 id="name">lr</h2>
            <h3 id="title">Android server web Go</h3>
            <span id="location"><i class="fa fa-map-marker"></i>china, Hainan</span>
            <a id="follow" target="_blank" href="https://github.com/mccapp">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                81
                <span>文章</span>
            </div>
            <div class="article-info-block">
                36
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://gitee.com/mccapp" target="_blank" title="github">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://twitter.com/" target="_blank" title="twitter">
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.facebook.com/" target="_blank" title="facebook">
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://dribbble.com/" target="_blank" title="dribbble">
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/atom.xml" target="_blank" title="rss">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-offce002" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/12/13/offce002/">offce 002</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/12/13/offce002/">
            <time datetime="2020-12-13T04:10:55.000Z" itemprop="datePublished">2020-12-13</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/offce/">offce</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/offce/">offce</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h5 id="标记算法："><a href="#标记算法：" class="headerlink" title="标记算法："></a>标记算法：</h5><p>1.引用计数法<br>2.可达性分析法(注意GC root的类型，虚拟机栈和本地方法栈引用的对象、静态对象、字节码对象)</p>
<h3 id="回收算法（复制算法、标记清除、标记整理）"><a href="#回收算法（复制算法、标记清除、标记整理）" class="headerlink" title="回收算法（复制算法、标记清除、标记整理）"></a>回收算法（复制算法、标记清除、标记整理）</h3><p>新生代：对象存活率低，采用复制算法，堆中分为3个区域，Eden、from、to，每次分配对象都在Eden，第一次gc时，把存活对象复制到from，第二次gc把Eden和from的对象复制到to，第三次又把Eden和to的对象复制到from，依次往复。达到一定阈值时，把对象移入老年代。</p>
<p>老年代：对象存活率高，标记整理法</p>
<h3 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h3><ul>
<li><p>双亲委托机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完</p>
</li>
<li><p>成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
</li>
<li><p>Java的类加载器：根加载器（加载java核心类）、扩展类加载器（加载jre扩展目录）、应用类加载器（加载classPath指定目录的类，自定义类加载器一般继承此加载器）</p>
</li>
<li><p>Android的类加载器：根加载器、BaseDexClassLoader、PathClassLoader（加载安装到系统的APK）、DexClassLoader（加载指定目录的dex和apk）</p>
</li>
</ul>
<h3 id="java匿名内部类"><a href="#java匿名内部类" class="headerlink" title="java匿名内部类"></a>java匿名内部类</h3><p>匿名内部类就是没有名字的内部类，（其实是有名字的，虚拟机定位这个类，编译之后会使用 外部类名$1这样的名字，数字按顺序生成）。<br>匿名内部类的构造方法由编译器生成，参数列表包括：</p>
<ul>
<li><p>外部类的引用（定义在非静态域）</p>
</li>
<li><p>捕获的外部变量（方法体中使用的外部final对象）</p>
</li>
<li><p>父类的构造参数</p>
</li>
<li><p>如果父类也是一个非静态内部类则还有父类的外部类引用。</p>
</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><p>不能继承父类或者实现接口（kotlin中是可以的）</p>
</li>
<li><p>不能定义静态变量和方法</p>
</li>
<li><p>会持有外部类的引用，可能会造成内存泄露。</p>
</li>
</ul>
<p>拓展：lambda表达式可以替代部分匿名内部类，父类必须是接口，且只有一个方法。</p>
<h3 id="java泛型擦除"><a href="#java泛型擦除" class="headerlink" title="java泛型擦除"></a>java泛型擦除</h3><p>使用泛型可以声明集合存储的元素类型，取出元素时避免强转的操作。在java中，编译完成后泛型参数会被擦除，例如List<string>和List<integer>编译完成后都是List类型。</integer></string></p>
<h3 id="java泛型为什么会被擦除："><a href="#java泛型为什么会被擦除：" class="headerlink" title="java泛型为什么会被擦除："></a>java泛型为什么会被擦除：</h3><ul>
<li><p>运行时内存压力小，不同泛型的List都编译成同一个类型。泛型不擦除的语言如c#，在方法区就会真实存在各种不同的List类型，压力就会相对较大。</p>
</li>
<li><p>兼容性的问题，1.5之前是没有泛型的，java当时的用户量很大，为了向下兼容。  </p>
</li>
</ul>
<h3 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h3><p>1.基本类型无法用于泛型，只能用装箱类型，例如List，装箱操作有额外的开销。<br>2.泛型参数不能用于方法重载，因为编译完成后泛型被擦除，参数都是一样的。<br>3.泛型类型不能当做真实的类型来使用，例如方法参数中有一个泛型T，方法中不能直接new  T（），因为编译之后就是Object，不知道真实的类型。<br>4.静态方法无法引用类的泛型，因为类的泛型在实例化的时候才知道。<br>5.类型强转的额外开销。</p>
<p>泛型在特定场景可以通过反射获取，例如父类有一个泛型参数已经被确定，子类继承之后可以获取。例如gson中，解析带泛型的List，要传入一个TypeToken，实际上是new了一个子类，通过反射获取泛型类型。</p>
<h3 id="如何写出线程安全的程序？"><a href="#如何写出线程安全的程序？" class="headerlink" title="如何写出线程安全的程序？"></a>如何写出线程安全的程序？</h3><p>线程安全的本质，可变资源在线程间共享的问题。关键：可变资源、线程共享。</p>
<p>线程安全三要素：原子性、可见性、有序性</p>
<p>所以要保证线程安全：</p>
<p>1.共享不可变资源，final关键字的使用。<br>2.使用纯函数（不访问外部资源），使用ThreadLocal，不共享资源。<br>3.使用volatile关键字保证共享资源的可见性，并禁止指令重排序。<br>4.操作原子性（加锁保证操作的互斥性，原子类AtomicXXX的使用，CAS指令如Unsafe.compareAndSwap）</p>
<h3 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h3><p>底层通过一个监视器monitor实现，monitor对象包含一个count计数字段和owner字段指向获取锁的线程，当线程获取monitor后，count+1，owner指向线程，监视器处于锁定状态，其他线程不能获取monitor会进入阻塞状态，当前线程释放monitor后，其他线程可以继续竞争该锁。</p>
<h3 id="Java1-6之后对Synchronized进行了一些优化："><a href="#Java1-6之后对Synchronized进行了一些优化：" class="headerlink" title="Java1.6之后对Synchronized进行了一些优化："></a>Java1.6之后对Synchronized进行了一些优化：</h3><ul>
<li><p>锁自旋：线程的阻塞和唤醒需要 CPU 从用户态转为核心态，例如在Synchronized代码块中调用wait方法阻塞线程，wait会释放锁，所谓自旋，就是让该线程执行一段无意义的循环指令来等待一段时间，不会被立即挂起，看当前持有锁的线程是否会很快释放锁。缺点是需要占用 CPU，锁竞争的时间比较长时不实用）</p>
</li>
<li><p>偏斜锁：如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作，一旦出现锁竞争，偏向锁会被撤销，并膨胀成轻量级锁</p>
</li>
<li><p>轻量级锁：对于一块同步代码，虽然有多个不同线程会去执行，但是这些线程是在不同的时间段交替请求这把锁对象，也就是不存在锁竞争的情况。在这种情况下，锁会保持在轻量级锁的状态，从而避免重量级锁的阻塞和唤醒操作</p>
</li>
</ul>
<p>Synchronized可以修饰静态方法（锁对象为字节码对象）、实例方法（锁为实例对象）和代码块，无论是否发生异常虚拟机都会正常释放锁<br>ReentrantLock发生异常时不能释放锁，所以一般需要在finaly代码块中释放锁，它包含公平锁和读写锁等用法，使用更灵活</p>
<h3 id="java虚拟机内存模型"><a href="#java虚拟机内存模型" class="headerlink" title="java虚拟机内存模型"></a>java虚拟机内存模型</h3><ul>
<li><p>虚拟机栈：线程私有，随线程创建而创建。栈里面是一个一个“栈帧”，每个栈帧对应一次方法调用。栈帧中存放了局部变量表（基本数据类型变量和对象引用）、操作数栈、方法出口等信息。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误。</p>
</li>
<li><p>本地方法栈：线程私有，这部分主要与虚拟机用到的Native方法相关，一般情况下并不需要关心这部分内容。</p>
</li>
<li><p>程序计数器：也叫PC寄存器，JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native方法，则PC寄存器中为空。（PS：线程执行过程中并不都是一口气执行完，有可能在一个CPU时钟周期内没有执行完，由于时间片用完了，所以不得不暂停执行，当下一次获得CPU资源时，通过程序计数器就知道该从什么地方开始执行）</p>
</li>
<li><p>方法区：方法区存放类的信息（包括类的字节码，类的结构）、常量、静态变量等。字符串常量池就是在方法区中。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的是与Java堆区分开来。很多人都更愿意把方法区称为“永久代”（Permanent Generation）。从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的静态变量、字符串常量池等移到堆内存中。</p>
</li>
<li><p>堆：堆中存放的是数组（PS：数组也是对象）和对象。当申请不到空间时会抛出OutOfMemoryError。</p>
</li>
</ul>
<h3 id="class加载过程"><a href="#class加载过程" class="headerlink" title="class加载过程"></a>class加载过程</h3><p>1.装载，将class文件加载进内存，在堆中生成class对象<br>2.链接，验证二进制数据流（类结构是否正确），分配静态变量设置默认值（初始化时才真正赋值），将符号引用转换为直接引用<br>3.初始化，初始化静态变量，静态代码块</p>
<h3 id="java内存模型、volatile的作用"><a href="#java内存模型、volatile的作用" class="headerlink" title="java内存模型、volatile的作用"></a>java内存模型、volatile的作用</h3><h5 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h5><ul>
<li><p>本地内存：存放的是 私有变量 和 主内存数据的副本。如果私有变量是基本数据类型，则直接存放在本地内存，如果是引用类型变量，存放的是引用，实际的数据存放在主内存。本地内存是不共享的，只有属于它的线程可以访问。</p>
</li>
<li><p>主内存：存放的是共享的数据，所有线程都可以访问。当然它也有不少其他称呼，比如 堆内存，共享内存等等。</p>
</li>
</ul>
<p>Java内存模型规定了所有对共享变量的读写操作都必须在本地内存中进行，需要先从主内存中拿到数据，复制到本地内存，然后在本地内存中对数据进行修改，再刷新回主内存，这就导致了多线程情况下数据的可见性问题，可以使用volatile关键字来修饰</p>
<ul>
<li><p>volatile变量在修改后，会立即刷新主内存的值，对所有线程可见，当volatile变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程需要从主内存中去读取该变量的最新值。</p>
</li>
<li><p>volatile还可以防止指令重排序造成的线程安全问题，例如双重校验的懒汉式单例中，不加volatile的对象编译后的指令有可能重排序成：对象引用已经被赋值不等于null了，但是对象的构造方法还没有调用完成的情况。第二个线程去判断不为空，拿到的对象还未初始化完成造成错误。</p>
</li>
</ul>
<h3 id="如何安全停止一个线程"><a href="#如何安全停止一个线程" class="headerlink" title="如何安全停止一个线程"></a>如何安全停止一个线程</h3><p>stop方法，被废弃。强行停止一个线程，没有资源的机会，如果正在处理任务，会留下一堆异常的数据。另一个线程再访问时就会发生错误。那么如何安全的结束呢：<br>1、设置volatile的boolean标志位，修改标志位来判断是否继续执行还是清理现场。</p>
<p>2、Interrupt方法：线程内部也需要做支持，判断是否被中断，和标志位类似的处理。支持sleep等系统方法（sleep过程中中断）。判断是否中断的两个方法的区别：<br>interrupted，静态方法，获取当前正在执行的线程是否被中断，中断之后会清空状态，重复获取就返回falseisInterrupted，线程的方法，获取当前线程的中断状态，不会被清空状态</p>
<h3 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h3><p>底层是数组+链表的结构，默认数组长度16，加载因子0.75，在put时，（如果第一次put，会创建数组）如果元素个数大于数组长度*加载因子时，将触发扩容操作，数组长度翻倍，并重新计算hash将元素放入数组；</p>
<p>Java1.8中，如果元素过多，数组长64，链表长度超过8，将进行树化操作，将链表转为红黑树，红黑树的节点是链表节点占用空间的两倍，提高查询效率；</p>
<h5 id="如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂："><a href="#如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂：" class="headerlink" title="如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂："></a>如何计算元素存储的位置，如何解决hash冲突，为何数组长度必须为2的整数幂：</h5><p>先把key取hash值，然后进行一个二次hash，方式为(n-1)&amp;hash，这个二次hash是因为如果n正好等于2的幂，(n-1)&amp;hash相当于对n取模，这样位运算效率很高，这样就相当于把元素均匀分布到了数组中，如果数组的位置没有元素，直接保存元素，如果已经有元素了，表示发生了hash冲突，将改为链表的存储方式，把新元素放在头部（1.8中是尾插法）</p>
<h5 id="为什么加载因子为0-75？设为1和0-5有什么问题？"><a href="#为什么加载因子为0-75？设为1和0-5有什么问题？" class="headerlink" title="为什么加载因子为0.75？设为1和0.5有什么问题？"></a>为什么加载因子为0.75？设为1和0.5有什么问题？</h5><p>loadFactor太大，比如等于1，那么就会有很高的哈希冲突的概率，会大大降低查询速度。</p>
<p>loadFactor太小，比如等于0.5，那么频繁扩容没，就会大大浪费空间。</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>初始化容量不一样（11），线程安全对整个数组加锁，不允许null值，数据结构一直是数组+链表，不会转换为红黑树；</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap:"></a>ConcurrentHashMap:</h3><p>1.5-1.7采用分段锁segment机制，不再是整个数组加锁，而是对单条或者几条链表和红黑树进行加锁。内部结构如图：segment数组，segment中类似HashMap的数组+链表。要通过hash让元素尽可能的均匀分布到不同的segment和数组中，所以对key取hash，用高位确定segment的位置，然后用低位确定数组的位置。</p>
<p>1.5的hash算法不好，元素多的时候会造成新加的节点分布在最后的几个桶，分布不均匀，</p>
<p>1.6就改善了hash算法。</p>
<p>1.7的优化是采用segment的懒加载机制，并用volatile的方式访问数组，保证数组的线程可见性，结合CAS指令来避免加锁。</p>
<p>1.8中则基于hashmap做优化，不再采用分段锁，而是对桶节点加锁，使用volatile和CAS乐观锁来实现读和写，再次提高了效率。</p>
<p>通过对Hashtable和ConcurrentHashMap的比较，得出一些锁优化的方法论，比如大锁不如小锁，长锁不如短锁，读写锁的分离等等</p>
<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><h3 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a>线程池的参数</h3><p>1.corePoolSize：线程池大小，当向线程池提交任务时，如果线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会创建一个新的线程来执行任务，直到线程数大于或等于corePoolSize。（除了提交新任务来创建线程，也可以通过prestartCoreThread或prestartAllCoreThreads来提前创建核心线程）<br>2.maximumPoolSize：线程池最大大小，当任务队列满了，且已创建的线程数小于最大线程数，则创建新线程来执行任务，如果线程池任务队列为无界队列可以忽略该参数<br>3.keepAliveTime：线程存活时间，当线程数大于核心线程数时，线程空闲时间大于存活时间，那么这个线程将被销毁，如果线程池任务队列为无界队列可以忽略该参数<br>4.workQueue：任务队列，用于保存等待执行任务的阻塞队列<br>5.threadFactory：线程工厂，用于创建新线程，可以设置统一风格的线程名<br>6.handler：线程饱和策略，当任务队列和线程池都满了，继续提交任务将执行此策略</p>
<h3 id="如何配置线程池？需要看任务的类型"><a href="#如何配置线程池？需要看任务的类型" class="headerlink" title="如何配置线程池？需要看任务的类型"></a>如何配置线程池？需要看任务的类型</h3><p>cpu密集型需要配置较小的线程数，避免cpu过度切换反而效率低下<br>IO密集型，线程池可以稍大，提高cpu的利用率；混合型任务则可配置两个线程池分别来执行；</p>
<p>java自带的线程池</p>
<p>线程池                   核心线程    最大线程              存活时间           任务队列<br>CachedThreadPool        0          Integer.MAX_VALUE    60S               SynchronousQueue<br>FixedThreadPool         n          n                    0                 LinkedBlockingQueue<br>SingleThreadExecutor    1          1                    0                 LinkedBlockingQueue<br>ScheduledThreadPool     n          Integer.MAX_VALUE    0                 DelayWorkQueue</p>
<p>SynchronousQueue：只能有一个元素的队列，插入和获取元素都会阻塞线程</p>
<h3 id="java方法分派（多态）"><a href="#java方法分派（多态）" class="headerlink" title="java方法分派（多态）"></a>java方法分派（多态）</h3><p>子类复写父类方法，调用方法调用子类还是父类？ 取决于运行时具体的调用者类型，实例是子类就调用子类的方法。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li><p>对称加密和非对称加密</p>
</li>
<li><p>对称加密：加密和解密使用同一个秘钥，使用对应的加密和解密算法进行加解密</p>
</li>
<li><p>非对称加密：加密和解密使用不同的秘钥，分为公钥和私钥，公钥和私钥相互可解，意思就是私钥加密的密文只有公钥可解，反之亦然。</p>
</li>
<li><p>数字签名技术<br>​   非对称加密在实际使用中，公钥会公开出来，私钥保存在自己手中不公开。由于私钥加密的密文只有公钥可解，那么如果有一个密文用你的公钥可以解开，那么可以说明这个密文肯定是你的私钥加密的，这就诞生了数字签名技术。<br>​   只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明</p>
</li>
</ul>
<h3 id="https的本质"><a href="#https的本质" class="headerlink" title="https的本质"></a>https的本质</h3><p>https的本质就是：用非对称加密的方式协商出一个对称加密的会话秘钥来进行会话</p>
<ul>
<li>首先服务端需要有一个证书，证书包含了自己的公钥和服务端信息，如hash算法、加密算法、域名、有效期等等。此证书需要由可信任的第三方（CA机构）的私钥进行签名，实际上是对证书做一个hash，得到hash值然后签名，CA机构也可能不止一级而是一个证书链</li>
<li>为什么要用第三方机构来颁发证书呢？为了安全的传输自己的公钥，系统都预置了可信任的根证书，三方机构是否可信任由系统来保证</li>
</ul>
<h3 id="客户端如何校验CA证书"><a href="#客户端如何校验CA证书" class="headerlink" title="客户端如何校验CA证书"></a>客户端如何校验CA证书</h3><p>1.客户端收到证书后，用证书中的公钥去解密该Hash值，得到hash-a<br>2.客户端用证书中指定的签名算法，计算出一个hash-b，比较hash-a和hash-b<br>3.除了校验hash值，还会校验CA证书有效期和域名等</p>
<h3 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h3><p>1.客户端A访问服务端B，客户端生成一个随机数1、将自己支持的SSL版本号、加密套件（包括哈希算法和加密算法）等信息发送给服务端<br>2.服务端B收到请求，选择一个加密套件，也生成一个随机数2，将随机数和自己的证书一同返回给客户端<br>3.客户端收到证书，校验证书是否有效（方法之前说过了），通过校验后，生成一个随机数3，用证书中的公钥加密随机数3，发送给服务端B<br>4.服务端收到加密的随机数，用私钥解密<br>5.服务端和客户端都有了随机数1、2、3，通过这三个随机数，生成一个对称加密的会话密钥<br>6.服务端和客户端分别通知对方之后的会话用会话秘钥来完成，握手结束</p>
<h3 id="为什么要用非对称加密来握手，而用对称加密来会话"><a href="#为什么要用非对称加密来握手，而用对称加密来会话" class="headerlink" title="为什么要用非对称加密来握手，而用对称加密来会话"></a>为什么要用非对称加密来握手，而用对称加密来会话</h3><p>对称加密握手的话，由于双方的秘钥是一样的，相当于秘钥公开了，和没加密没有区别<br>而会话阶段，对称加密效率较非对称高</p>
<h3 id="TCP为什么要三次握手和四次挥手"><a href="#TCP为什么要三次握手和四次挥手" class="headerlink" title="TCP为什么要三次握手和四次挥手"></a>TCP为什么要三次握手和四次挥手</h3><ul>
<li>“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。例如：第一次请求由于网络拥堵没有到达服务端，客户端又发起第二次请求，正常完成了连接，传输完数据之后断开，这时第一次的请求到达了服务端，如果没有第三次握手，会直接建立一条没有用的连接，server端一直等待，浪费资源。</li>
</ul>
<p>+“四次挥手”原因是因为tcp是全双工模式，接收到FIN时意味对方将没有数据再发来，但是自己还是可以继续发送数据。</p>
<h3 id="为什么TCP是可靠的？"><a href="#为什么TCP是可靠的？" class="headerlink" title="为什么TCP是可靠的？"></a>为什么TCP是可靠的？</h3><h3 id="TCP基于连接，具有以下机制："><a href="#TCP基于连接，具有以下机制：" class="headerlink" title="TCP基于连接，具有以下机制："></a>TCP基于连接，具有以下机制：</h3><ul>
<li>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。</li>
<li>数据校验。</li>
<li>数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。</li>
<li>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。</li>
<li>拥塞控制：当网络发生拥塞时，减少数据的发送。</li>
</ul>
<p>UDP是无连接、不安全的，每个数据包都包含接收的ip等信息，客户端只管发送，没有确认重传机制，所以速度更快，但是可能会丢包。</p>
<h3 id="HTTP1-0、1-1、2-0的区别"><a href="#HTTP1-0、1-1、2-0的区别" class="headerlink" title="HTTP1.0、1.1、2.0的区别"></a>HTTP1.0、1.1、2.0的区别</h3><h5 id="1-1和1-0："><a href="#1-1和1-0：" class="headerlink" title="1.1和1.0："></a>1.1和1.0：</h5><ul>
<li><p>增加新的控制缓存策略的Header，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match；</p>
</li>
<li><p>增加了range请求头，允许请求资源的一部分，支持了多线程断点续传下载，优化了带宽和连接；</p>
</li>
<li><p>增加了Host头，允许一台物理服务器上存在多个虚拟主机，共享一个IP地址，通过Host来区分；</p>
</li>
<li><p>增加了keep-alive支持TCP长连接，一定程度弥补了每次请求都重新创建连接的情况；</p>
</li>
</ul>
<h4 id="SPDY："><a href="#SPDY：" class="headerlink" title="SPDY："></a>SPDY：</h4><p>SPDY是Http1.x版本的优化方案，包括多路复用技术、请求优先级（多路复用时，多个请求并行于共用的TCP连接，可以设置请求的优先级防止关键请求被阻塞）、header压缩和服务端推送功能；SPDY的特性并入了Http2.0中；</p>
<h4 id="1-1和2-0："><a href="#1-1和2-0：" class="headerlink" title="1.1和2.0："></a>1.1和2.0：</h4><ul>
<li><p>支持了新的二进制格式，1.x版本只支持文本协议</p>
</li>
<li><p>多路复用技术，在HTTP/1.1协议中，同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。多个请求是串行处理，当一个请求超时，后续请求就会被阻塞，而在2.0中，一个TCP连接上并行多个请求，某个请求耗时不影响其他连接；</p>
</li>
<li><p>Header压缩，多个请求可以差量更新Header字段，降低流量提高效率；</p>
</li>
<li><p>服务端推送功能</p>
</li>
</ul>
<h3 id="三方授权方式"><a href="#三方授权方式" class="headerlink" title="三方授权方式"></a>三方授权方式</h3><ul>
<li><p>Basic：格式：Authorization: Basic username:password(Base64ed)</p>
</li>
<li><p>Bearer：格式：Authorization: Bearer </p>
</li>
</ul>
<h3 id="bearer-token-的获取⽅式（-OAuth2-的授权流程）："><a href="#bearer-token-的获取⽅式（-OAuth2-的授权流程）：" class="headerlink" title="bearer token 的获取⽅式（ OAuth2 的授权流程）："></a>bearer token 的获取⽅式（ OAuth2 的授权流程）：</h3><p>1.第三⽅⽹站向授权⽅⽹站申请第三⽅授权合作，拿到 client id 和 client secret</p>
<p>2.⽤户在使⽤第三⽅⽹站时，点击「通过 XX (如 GitHub) 授权」按钮，第三⽅⽹站将⻚⾯跳转到授权⽅⽹站，并传⼊ client id 作为⾃⼰的身份标识</p>
<p>3.授权⽅⽹站根据 client id ，将第三⽅⽹站的信息和需要的⽤户权限展示给⽤户，询问⽤户是否同意授权</p>
<p>4.⽤户点击「同意授权」按钮后，授权⽅⽹站将⻚⾯跳转回第三⽅⽹站，并传⼊ Authorization code 作为⽤户认可的凭证。</p>
<p>5.第三⽅⽹站将 Authorization code 发送回⾃⼰的服务器</p>
<p>6.服务器将 Authorization code 和 client secret ⼀并发送给授权⽅的服务器，授权⽅返回 access token。</p>
<h3 id="WebSocket和Socket的区别"><a href="#WebSocket和Socket的区别" class="headerlink" title="WebSocket和Socket的区别"></a>WebSocket和Socket的区别</h3><ul>
<li>WebSocket是应用层的一个持久化协议，http它一次请求和响应就断开连接，属于非持久化协议。WebSocket分为握手和数据传输两个阶段，采用http协议握手然后建立全双工的tcp连接。</li>
<li>Socket是传输层的一个协议抽象，包括TCP和UDP，TCP基于连接，拥有确认和重传，拥塞控制和流程控制等机制的可靠的协议。UDP则面向无连接，基于数据报，相对于TCP速度快但不可靠。</li>
</ul>
<h3 id="多线程下载和断点续传"><a href="#多线程下载和断点续传" class="headerlink" title="多线程下载和断点续传"></a>多线程下载和断点续传</h3><p>两个核心Header，Content-Length表示文件的总字节数，RANGE表示从某一个位置开始传输。</p>
<p>首先，获取到文件大小后，通过线程数来计算每个线程下载的开始位置。</p>
<p>然后，通过range来设置从哪个位置传输。</p>
<p>当暂停或者退出时，记录已下载的位置，下次恢复后从记录的位置下载。</p>
<p>使用RandAccessFile来保存文件，这个类的特点是可以通过移动文件指针来设置写入的位置。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2020/12/13/offce002/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-面试题001" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/12/12/面试题001/">offce 001</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/12/12/面试题001/">
            <time datetime="2020-12-12T03:10:55.000Z" itemprop="datePublished">2020-12-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/offce/">offce</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/offce/">offce</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h3 id="View的绘制流程、Activity、Window、View的关系"><a href="#View的绘制流程、Activity、Window、View的关系" class="headerlink" title="View的绘制流程、Activity、Window、View的关系"></a>View的绘制流程、Activity、Window、View的关系</h3><p>Activity启动时创建Window、ViewRoot并建立关联，流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ActivityThread &#123;</span><br><span class="line">  // startActivity最终会调用到这里</span><br><span class="line">  fun handleLaunchActivity()&#123;</span><br><span class="line">	// 1. performLaunchActivity() 创建activity</span><br><span class="line">    // 2. activity.attach() 内部创建了PhoneWindow</span><br><span class="line">    // 3. activity.onCreate() -&gt; setContentView，实际调用window的对应方法，创建DecorView </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fun handleResumeActivity()&#123;</span><br><span class="line">    // 1. activity.onResume()</span><br><span class="line">    // 2. 获取activity的window对象，添加DecorView到WindowManagerGlobal中</span><br><span class="line">    // 3. WindowManagerGlobal.addView(DecorView)时，创建了ViewRootImpl，所有view绘制的工作都是</span><br><span class="line">    //		ViewRootImpl来调度，在这里才建立了ViewRootImpl和View的关联</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewRoot &#123;</span><br><span class="line">// ViewRoot添加view后，会执行ViewRoot.requestLayout</span><br><span class="line">// scheduleTraversals -&gt; 在消息队列中插入一个同步消息屏障,保证UI优先绘制 </span><br><span class="line">//  -&gt; 通过choreographer提交绘制任务，同时向底层请求sync信号，</span><br><span class="line">//  -&gt; 在下一次信号到来时JNI回调doTraversal，并移除屏障消息</span><br><span class="line">//  -&gt; doTraversal中调用了performMeasure、performLayout和performDraw进行测量、布局和绘制流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MeasureSpec是一个32位int值，高2位表示测量模式，后30位表示在该模式下的测量值，一个view的MeasureSpec由自己的LayoutParams和父View的MeasureSpec共同决定。测量过程实际是递归的测量子view后再设置自己的尺寸。</p>
<h3 id="onCreate、onResume中能否获取到View的宽高，为什么？"><a href="#onCreate、onResume中能否获取到View的宽高，为什么？" class="headerlink" title="onCreate、onResume中能否获取到View的宽高，为什么？"></a>onCreate、onResume中能否获取到View的宽高，为什么？</h3><p>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View还没有测量完毕，那么获得的宽/高就是0。所以在onCreate、onStart、onResume中均无法正确得到某个View的宽高信息。<br>解决方式如下：</p>
<p>1.view.post(runnable)，注意这里handler.post(runnable)是不行的，View.post会先判断attachInfo是否为空，如果为空就放到一个等待执行的队列中，等待View被添加（dispatchAttachedToWindow）之后才执行，这时测量已经完毕了，如果不为空，表示View已经被添加，就调用attachInfo中的Handler来post任务，所以是一定能获取到的。注意api23以下和以上的逻辑不一样：</p>
<p>Api23以下：调用的ViewRootImpl.getRunQueue().post()，执行时机是doTraversa()中，这个方法又是在下一个同步信号来的时候调用的，参考屏幕刷新机制。</p>
<ul>
<li>Api23以上：调用的是getRunQueue().post() ，它的执行时机是View被添加之后执行，如果View只是创建出来没有被添加，那将一直得不到执行。</li>
</ul>
<p>2.使用ViewTreeObserver</p>
<h3 id="卡顿原理、屏幕刷新机制、卡顿监控"><a href="#卡顿原理、屏幕刷新机制、卡顿监控" class="headerlink" title="卡顿原理、屏幕刷新机制、卡顿监控"></a>卡顿原理、屏幕刷新机制、卡顿监控</h3><h3 id="卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有："><a href="#卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有：" class="headerlink" title="卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有："></a>卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有：</h3><p>1.主线程有耗时操作（合理使用线程来执行耗时任务）<br>2.View本身太复杂、嵌套过多导致绘制超过16ms（优化View的层级、合理使用include、ViewStub标签）<br>3.内存抖动造成频繁GC，例如循环内部创建对象，onDraw中创建对象等。（优化内存泄漏、对一些需要频繁创建的对象采用对象池技术）</p>
<h3 id="屏幕刷新机制："><a href="#屏幕刷新机制：" class="headerlink" title="屏幕刷新机制："></a>屏幕刷新机制：</h3><ul>
<li>底层每间隔16毫秒会发出vsyn信号，View 的 requestLayout 会调到ViewRootImpl 的 requestLayout方法，然后通过 scheduleTraversals 方法向Choreographer 提交一个绘制任务，再通过DisplayEventReceiver向底层请求vsync信号，当vsync信号来的时候，会通过JNI回调回来，通过Handler往主线程消息队列post一个异步任务，最终是ViewRootImpl去执行那个绘制任务，调用performTraversals方法，里面是View的三个方法的回调。</li>
</ul>
<h3 id="监控卡顿"><a href="#监控卡顿" class="headerlink" title="监控卡顿"></a>监控卡顿</h3><p>1.基于handler消息队列，如BlockCanary，handler分发消息前后都会打印日志，可以自定义Printer，计算Looper两次获取消息的时间差，如果时间太长就说明Handler处理时间过长，直接把堆栈信息打印出来，就可以定位到耗时代码<br>2.代码插桩，在方法的前后插入计时代码来监控执行时间，缺点是包增大，无法监控系统方法，并且需要过滤简单方法<br>3.循环插入空消息到消息队列，监控这个消息的处理时间，例如每隔1秒插入一条空消息，如果这条消息处理时间间隔大于一定时间，则认为发生了卡顿</p>
<h3 id="RxJava的原理"><a href="#RxJava的原理" class="headerlink" title="RxJava的原理"></a>RxJava的原理</h3><p>Rxjava每个操作符会生成一个新的Observable,同时持有上游事件源和下游Observer，最终在subscribeActual中实现自己的操作逻辑，并连接上下游。<br>Rxjava有点像观察者模式和责任链模式的结合，普通的观察者模式一般是被观察者通知多个观察者，而Rxjava则是被观察者通知第一个Obsever,接下来Observer依次通知下一个节点的Observer，形成一个“观察链”，将观察者模式进行了一种类似链式的变换，每个节点又会执行它不同的“职责”。</p>
<p>1.SubscribeOn节点在订阅的时候，将它的上游节点的subscribe操作，以runnable的形式交给调度器在执行，在io调度器就是一个线程池，他影响的是事件源的发射行为，如果多次subscribeOn相当后一次subscribeOn把上一次subscribeOn行为在线程池里执行了一次，最终就只有最上边的一个起作用；<br>2.observeOn会将它下游的Observer放到切换的线程中执行，因此observeOn影响的是它的下游，多次调用影响的是这次到下一次observeOn之间的代码；</p>
<h3 id="Rxjava中调度器"><a href="#Rxjava中调度器" class="headerlink" title="Rxjava中调度器"></a>Rxjava中调度器</h3><ul>
<li>Schedulers.io()：无边界线程池作为支撑的一个Scheduler，线程可以无限增长，它适用于非CPU密集的I/O工作，比如访问文件系统、执行网络调用、访问数据库等</li>
<li>Schedulers.computation()：用于执行CPU密集的工作，比如处理大规模的数据集、图像处理等等。它由一个有界的线程池作为支撑，线程的最大数量就是可用的处理器数量</li>
<li>Schedulers.newThread()：这个Scheduler 每次都会创建一个全新的线程来完成一组工作</li>
<li><strong>Schedulers.single()：</strong>只有一个线程作为支撑，只能按照有序的方式执行任务</li>
<li><strong>Schedulers.from(Executor executor)</strong>我们可以使用它创建自定义的Scheduler</li>
<li>AndroidSchedulers.mainThread()：Android主线程调度器</li>
</ul>
<h3 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h3><p>事件传递的顺序：Activity-&gt;Window-&gt;DecorView</p>
<p>dispatchTouchEvent中：</p>
<p>1.判断是否需要拦截事件的标记intercepted<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 如果是down事件或者mFirstTouchTarget不为空</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123;</span><br><span class="line">  final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">  if (!disallowIntercept) &#123;</span><br><span class="line">    // 判断disallowIntercept标记</span><br><span class="line">    // 如果允许拦截则调用onInterceptTouchEvent</span><br><span class="line">    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 有disallowIntercept标记，不拦截</span><br><span class="line">    intercepted = false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 已有mFirstTouchTarget或者不是down时间，直接拦截</span><br><span class="line">  intercepted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.尝试分发事件：如果第一步不需要拦截，并且不是cancel状态，分发给子view</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">	// 遍历子view，判断坐标是否在view范围内并且view没有处于动画状态</span><br><span class="line">  // 满足条件则交给子view的dispatchTouchEvent来处理</span><br><span class="line">  // 如果子view处理了事件，则把子view赋值给mFirstTouchTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.再次分发事件：判断firstTouchTarget是否为空，如果为空表示没有子view处理事件，则间接的交给自己的onTouchEvent来处理，为空则直接交给firstTouchTarget处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mFirstTouchTarget == null) &#123;</span><br><span class="line">  // 没有子view处理事件，交给自己的onTouchEvent处理</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 直接交给mFirstTouchTarget处理后续事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<strong>onTouchListener ：</strong>如果有onTouchListener则优先交给onTouchListener处理，onTouchListener返回true则onTouchEvent将不会调用<br>5.cancel事件：父视图先不拦截，然后在 MOVE 事件中重新拦截，此时子 View 会接收到一个 CANCEL 事件，例如move出子view范围，或者scrollView中事件首先传递给子view，如果滑动则会被拦截。</p>
<h3 id="LeakCanary原理"><a href="#LeakCanary原理" class="headerlink" title="LeakCanary原理"></a>LeakCanary原理</h3><ul>
<li><p>首先java的四种引用，强、软、弱、虚四种引用，配合ReferenceQueue使用，在构造弱引用时传入ReferenceQueue，在垃圾回收之前，会将引用放入队列中，可以通过队列中是否有对象的引用来判断对象是否被回收；</p>
</li>
<li><p>具体就是在Application中注册ActivityLifecycleCallbacks监听activity的生命周期，在onDestory的时候，新建一个弱引用传入队列，在线程空闲的时候，会尝试清除队列的弱引用，如果成功则没有发生泄漏，如果失败，则尝试GC，GC之后再<br>次尝试清除弱引用，如果失败则发生了内存泄漏</p>
</li>
<li><p>Fragment也类似，在Activity创建时获取到FragmentManager注册一个fragmentLifecycleCallbacks，然后观察fragment；</p>
</li>
</ul>
<h3 id="Retrofit原理"><a href="#Retrofit原理" class="headerlink" title="Retrofit原理"></a>Retrofit原理</h3><ul>
<li><p>核心原理：在createService时，创建一个Api接口的动态代理，在loadServiceMethod方法先查找缓存，没有找到则解析Api接口，解析包括两部分，一个是方法上的注解，包括url、Header、请求参数等，第二个是方法的返回类型和参数类型，也就是CallAdapter和ConverAdapter</p>
</li>
<li><p>CallAdapter用于把结果适配成Rxjava、kotlin协程等返回类型</p>
</li>
<li><p>ConverAdapter用于把参数转化为json或者其他格式传输。</p>
</li>
<li><p>loadServiceMethod完毕后，实际上是把请求组装成一个OkHttpCall，用okhttp来进行具体的请求。</p>
</li>
</ul>
<h3 id="OkHttp原理"><a href="#OkHttp原理" class="headerlink" title="OkHttp原理"></a>OkHttp原理</h3><p>优点：连接池技术复用连接，可以降低延迟，无缝支持gzip减少数据量，支持http2以及SPDY多路复用技术</p>
<p>责任链设计模式：用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕</p>
<h3 id="请求流程："><a href="#请求流程：" class="headerlink" title="请求流程："></a>请求流程：</h3><p>1.构建request<br>2.通过dispatcher执行请求，dispatcher内部包含三个队列：同步请求队列、异步等待队列和异步执行队列，对于同步请求，直接添加到同步请求队列执行，异步请求则添加到等待队列中，然后判断请求数是否大于最大请求数、以及同一个主机的最大请求数，如果可以执行，则提升到执行队列进行执行<br>3.无论是同步请求还是异步请求，最终都调用到getResponseWithInterceptorChain方法，核心就是拦截器链，包含了7大拦截器，分别负责不同的功能，每一个拦截器都可以自己处理请求，然后直接返回或者交给下一节点来处理。</p>
<p>自定义拦截器<br>    RetryAndFollowUpInterceptor：重试和重定向拦截器<br>    BridgeInterceptor：用来设置一些必要的header<br>    CacheInterceptor：处理缓存<br>    ConnectInterceptor：负责建立服务器连接，优先从连接池中找到可用连接(soket连接是否可用，是否超时等，如不可用则会从连接池中移除)，否则打开一个新的连接<br>    自定义网络拦截器<br>    CallServerInterceptor：最后一个拦截器，用于真正发送网络请求，返回response</p>
<h3 id="为什么要组件化，怎么实现？了解的路由框架"><a href="#为什么要组件化，怎么实现？了解的路由框架" class="headerlink" title="为什么要组件化，怎么实现？了解的路由框架"></a>为什么要组件化，怎么实现？了解的路由框架</h3><ul>
<li>痛点：在业务开发中，各个业务模块依赖关系复杂，耦合严重，造成app编译缓慢、不能并行开发、组件复用性不高的问题。通过组件化改造，可以对各个模块进行了业务隔离，使模块可以单独编译运行，降低耦合度，提高了开发和调试效率。</li>
</ul>
<h5 id="组件拆分："><a href="#组件拆分：" class="headerlink" title="组件拆分："></a>组件拆分：</h5><ul>
<li><p>应用入口：一个空壳app，提供应用的启动页面</p>
</li>
<li><p>支撑业务组件：网络请求、图片加载等一些支撑服务</p>
</li>
<li><p>通用业务模块：例如支付、推送、地图等sdk，封装后对外提供调用接口</p>
</li>
<li><p>应用业务组件：具体的业务，可以提出来作为一个单独应用的功能模块，两两之间不互相依赖</p>
</li>
</ul>
<h5 id="模块间的通信，需要引入路由框架，主流路由框架大概分为两种"><a href="#模块间的通信，需要引入路由框架，主流路由框架大概分为两种" class="headerlink" title="模块间的通信，需要引入路由框架，主流路由框架大概分为两种"></a>模块间的通信，需要引入路由框架，主流路由框架大概分为两种</h5><ul>
<li><p>ARouter：路由表+接口下沉的方式，在编译期间通过注解处理器扫描目标类，然后解析参数生成路由表，<br>模块服务通过接口下沉的方式，把接口定义在公共库中，具体实现类在业务模块中，在编译时通过扫描字节码发现实现类，然后通过ASM等字节码修改技术完成服务的注册；</p>
</li>
<li><p>CC：组件总线的方式，类似于EventBus发送消息一样，直接找到目标组件，发送一条指令执行对应操作，<br>通过gradle的Transform API:在编译时(dex/proguard之前)扫描当前要打包到apk中的所有类 ，然后通过ASM技术修改字节码，生成代码完成组件的注册；</p>
</li>
</ul>
<h3 id="android优化的数据结构：SparseArray、ArrayMap"><a href="#android优化的数据结构：SparseArray、ArrayMap" class="headerlink" title="android优化的数据结构：SparseArray、ArrayMap"></a>android优化的数据结构：SparseArray、ArrayMap</h3><ul>
<li><p>SparseArray的key只能为int，双列数组结构，优化了自动装箱的过程，并且会自动排序，查找采用二分查找，在数据量不大的情况下效率高</p>
</li>
<li><p>ArrayMap和SparseArray类似，但是key可以是对象，存储的时候存储通过key的hash值排序，也采用二分查找；</p>
</li>
</ul>
<h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>1.广播</p>
<p>2.Messenger，封装的Binder，可以执行简单的串行通信。</p>
<p>3.ContentProvider，适用于进程间的数据共享，可以进行操作权限的控制，如数据库的读写等。</p>
<p>4.Socket，适用于网络通信，用于传输原始的字节流，两次拷贝、效率低于binder</p>
<p>5.Binder，适用于复杂的进程通信，功能强大，CS架构，底层基于内存映射，只进行一次拷贝，所以效率高，可以验证通信的进程id，所以比socket更安全。</p>
<h3 id="AIDL和Binder机制"><a href="#AIDL和Binder机制" class="headerlink" title="AIDL和Binder机制"></a>AIDL和Binder机制</h3><p>AIDL实际上是一套快速实现Binder通信的工具，通过定义AIDL接口，系统会自动生成一个类实现IInterface接口，内部包含Stub和Proxy两个内部类。服务端继承Stub提供服务。</p>
<h5 id="关键类和方法"><a href="#关键类和方法" class="headerlink" title="关键类和方法"></a>关键类和方法</h5><ul>
<li><p>Stub：服务端通过继承Stub，实现定义的接口来提供服务</p>
</li>
<li><p>Proxy：服务端对象的本地代理，客户端通过它来间接调用服务端接口的方法</p>
</li>
<li><p>asInterface：客户端调用，将binder对象转化为AIDL接口类型对象，如果和服务端在同一进程，返回Stub对象本身，否则返回Stub.proxy代理对象</p>
</li>
<li><p>asBinder：返回binder对象</p>
</li>
<li><p>onTransact：运行在服务端binder线程池，客户端请求时，远程请求会被系统封装后交给此方法处理</p>
</li>
<li><p>transact：运行在客户端，客户端发起请求时线程挂起，调用到服务端onTransact，等待其返回后才继续执行</p>
</li>
</ul>
<h3 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h3><ul>
<li><p>基于C/S架构，包括Server、Client、ServiceManager和Binder驱动，其中Binder驱动运行在内核空间，其他的运行在用户空间</p>
</li>
<li><p>ServiceManager负责服务管理，服务端向ServiceManager注册后，客户端可以向ServiceManager查询获取到目标服务的引用</p>
</li>
<li><p>Binder驱动：负责进程之间的Binder通信的建立，基于内存映射技术，传统的通信方式需要将数据从用户空间拷贝到内核空间，然后从内核空间拷贝到目标进程的用户空间，需要两次拷贝，Binder驱动可以建立用户空间内存和内核空间内存的一个映射，</p>
</li>
<li><p>只需要一次拷贝，非常高效。</p>
</li>
</ul>
<h3 id="kotlin的扩展方法是怎么实现的，inline关键字的作用"><a href="#kotlin的扩展方法是怎么实现的，inline关键字的作用" class="headerlink" title="kotlin的扩展方法是怎么实现的，inline关键字的作用"></a>kotlin的扩展方法是怎么实现的，inline关键字的作用</h3><ul>
<li>扩展方法编译成java后，实际上是一个 public static的静态方法，传入了对象实例和参数</li>
<li>Inline关键字修饰的函数是内联函数，用于优化函数调用的压栈操作，相当于在编译期间把内联函数的代码拷贝到函数调用处，可以提升性能，但是增加了代码量</li>
</ul>
<h3 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h3><h5 id="关键类："><a href="#关键类：" class="headerlink" title="关键类："></a>关键类：</h5><ul>
<li><p>Handler：用于发送消息和处理消息，发送消息就是将消息对象放入当前线程的MessageQueue中，然后Looper轮询到消息后交给自己处理，构造时需要传入Looper或者自动获取当前线程的Looper</p>
</li>
<li><p>Looper：轮询器，一个线程只能有一个Looper，用于从消息队列中轮询消息，然后交给对应的Handler处理</p>
</li>
<li><p>MessageQueue：消息队列，是一个阻塞队列，当没有消息是线程会被阻塞，等待有消息时唤醒线程</p>
</li>
<li><p>Message：消息对象，采用了对象池技术，可以避免对象的频繁创建开销</p>
</li>
</ul>
<h3 id="消息的发送和轮询"><a href="#消息的发送和轮询" class="headerlink" title="消息的发送和轮询"></a>消息的发送和轮询</h3><ul>
<li>发送消息：最终都会调用MessageQueue的enqueueMessage中，如果队列中没有消息或者消息的发送时间小于第一个消息，则直接放入队列头部，否则则根据时间插入到队列中的合适位置，同时会刷新needWeak标记，然后判断needWeak，如果需要唤醒，调用naviteWeak唤醒Looper。</li>
</ul>
<ul>
<li>获取消息：核心方法为MessageQueue的next，首先调用nativePollOnce，这个方法是一个native阻塞方法（通过监控文件描述符的io操作来实现），新消息放入队列时，会调用naviteWeak来唤醒。唤醒之后，如果是消息屏障就先处理异步消息，否则判断消息执行时间是否到达来返回消息或者进入下一个循环继续阻塞。</li>
</ul>
<ul>
<li>IdleHandler：在消息队列空闲的时候，会尝试执行IdleHandler的任务</li>
</ul>
<ul>
<li>消息屏障机制：当messageQueue取出屏障消息时，会开启循环，找到下一个异步消息执行，相当于阻塞了同步消息而优先执行异步消息，Android中所有UI绘制都是异步消息，可以保证UI绘制任务优先执行。</li>
</ul>
<h3 id="postDelay怎么保证消息的顺序"><a href="#postDelay怎么保证消息的顺序" class="headerlink" title="postDelay怎么保证消息的顺序"></a>postDelay怎么保证消息的顺序</h3><p>发送消息时会对消息队列按执行时间进行排序，如果没有消息或者当前消息执行时间小于队列的第一条消息，则直接插入到表头，否则会插入到合适的位置，保证delay时间长的不会阻塞住时间短的。</p>
<h3 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h3><p>1.Luancher 进程通过binder向AMS发起startActivity请求<br>2.AMS收到请求， ActivityStarter解析flag，启动模式等，ActivityStack处理activity栈<br>3.然后AMS通过socket调用到Zygote，fork新的app进程<br>4.app进程创建后，再通过binder向AMS发起attachApplication请求<br>5.AMS通过binder调用发送scheduleLaunchActivity到app进程<br>6.APP进程的binder线程ApplicationThread接收到请求，通过handler发送LAUNCH_ACTIVITY消息到主线程<br>7.ActivityThread接收到消息，执行到handleLaunchActivity，开始Activity的生命周期<br><img src="/2020/12/12/面试题001/../../../../images/a3aed8572f104535a3b0e679ea8c4cd9_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"><br>应用第一次启动时，zygote进程fork出应用进程后，AMS会保存一个ProcessRecord信息（包名+进程uid），下一次启动判断这个ProcessRecord已经存在的话，就不会再新建进程，这就属于应用内打开Activity的过程了</p>
<h3 id="APK打包流程"><a href="#APK打包流程" class="headerlink" title="APK打包流程"></a>APK打包流程</h3><p><img src="/2020/12/12/面试题001/../../../../images/4689f854f716495ea598a49d6ddac2b0_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"></p>
<p>1.打包资源文件，生成R.java文件<br>2.处理aidl文件，生成相应的Java文件<br>3.编译项目源代码，生成class文件（所有的Java代码，包括R.java和.aidl文件）<br>4.转换所有的class文件，生成classes.dex文件<br>5.打包生成APK文件<br>6.对APK文件进行签名<br>7.对签名后的APK文件进行对齐处理。对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用</p>
<h3 id="APK安装流程："><a href="#APK安装流程：" class="headerlink" title="APK安装流程："></a>APK安装流程：</h3><p>1.拷贝阶段：通过PMS通过handler发送一个安装消息，包含一些安装的参数，PackageHandler收到消息后通过隐式intent绑定到拷贝的service。检查apk安装路径，包的状态，然后拷贝至/data/app包名下<br>2.装载阶段：installPackageLI，PackageParser解析AndroidManifest文件，解析四大组件等信息<br>3.验证apk的签名信息<br>4.执行 dex 优化，实际为 dex2oat 操作，用来将 apk 中的 dex 文件转换为 oat 文件<br>5.安装apk，创建data目录，安装成功则更新权限等信息<br>6.发送成功广播，安装失败则删除安装包和缓存</p>
<h3 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h3><p>1.开机加载BootLoader，加载Linux内核<br>2.启动Init进程<br>3.读取init.rc配置文件，启动几个关键进程，包括Zygote、ServiceManager、SurfaceFlinger和MediaServer<br>4.zygote进程启动java runntime，然后fork出sytem_server进程<br>5.sytem_server启动AMS、WMS、电源管理、等等系统服务，并通过Binder注册到ServiceManager。<br>6.启动Launcher显示桌面<br><img src="/2020/12/12/面试题001/../../../../images/96bd5c17c1374385971a2ad840d964bc_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"></p>
<h3 id="Webview的漏洞"><a href="#Webview的漏洞" class="headerlink" title="Webview的漏洞"></a>Webview的漏洞</h3><p>1.4.2版本的addJavascriptInterface 造成的远程代码执行漏洞，当JS拿到Android这个对象后，就可以调用Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而执行任意代码</p>
<pre><code>4.2版本以上通过对调用的方法添加JavascriptInterface注解避免漏洞
4.2以下采用url拦截或者js弹窗拦截的方式进行交互，不能采用对象映射
</code></pre><p>2.密码明文存储<br>3.域控制不严问题，允许导出的WebActivity未关闭file协议，可以外部启动并加载恶意file协议的文件，从而访问私有文件，所以不需要使用file协议的，需要关闭</p>
<h4 id="Dalvik与ART的区别"><a href="#Dalvik与ART的区别" class="headerlink" title="Dalvik与ART的区别"></a>Dalvik与ART的区别</h4><p>1.Dalvik：即时编译，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，所以运行效率相对ART较低。由于不需要预编译，所以安装过程较快<br>2.ART ：应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高<br>3.ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%）<br>4.预编译也可以明显改善电池续航，从而减少了 CPU 的使用频率，降低了能耗。</p>
<h3 id="热修复和插件化原理"><a href="#热修复和插件化原理" class="headerlink" title="热修复和插件化原理"></a>热修复和插件化原理</h3><p>java类加载机制</p>
<ul>
<li><p>双亲委托机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
</li>
<li><p>Java的类加载器分为：根加载器（加载java核心类）、扩展类加载器（加载jre扩展目录）、应用类加载器（加载classPath指定目录的类，自定义类加载器一般继承此加载器）</p>
</li>
<li><p>Android的类加载器：根加载器、BaseDexClassLoader、PathClassLoader（加载安装到系统的APK）、DexClassLoader（加载指定目录的dex和apk）</p>
</li>
</ul>
<h3 id="热修复和插件化的区别"><a href="#热修复和插件化的区别" class="headerlink" title="热修复和插件化的区别"></a>热修复和插件化的区别</h3><ul>
<li><p>热修复：替换bug的类，需要把修复类抢先于bug类进行加载，让bug类得不到加载。通过反射修改DexClassLoader中DexPathList的dexElements数组，将需要加载的dex添加到数组前面。</p>
</li>
<li><p>插件化：运行未安装的插件apk的代码，不涉及到抢先加载，只需要将dex加载到dexElements中</p>
</li>
</ul>
<h3 id="热修复的CLASS-ISPREVERIFIED问题"><a href="#热修复的CLASS-ISPREVERIFIED问题" class="headerlink" title="热修复的CLASS_ISPREVERIFIED问题"></a>热修复的CLASS_ISPREVERIFIED问题</h3><p>热修复是需要修复有bug的类，所以需要把dex放在数组的前端抢先加载补丁类，在虚拟机启动的时候，在verify选项被打开的时候，如果static方法、private方法、构造函数等，其中直接引用到的类都在同一个dex文件中，那么该类就会被打上CLASS_ISPREVERIFIED标志，且一旦类被打上CLASS_ISPREVERIFIED标志其他dex就不能再去替换这个类。<br>​        为了阻止类被打上CLASS_ISPREVERIFIED标志，先将一个预备好的hack.dex加入到dexElements的第一项，让后面的dex的所有类都引用hack.dex其中的一个类。</p>
<h3 id="常见热修复框架"><a href="#常见热修复框架" class="headerlink" title="常见热修复框架"></a>常见热修复框架</h3><ul>
<li><p>Tinker实际上是类加载方案的升级，它增加了dex的差分算法，再将差分dex与apk中的classex.dex做合并，在运行bug类之前抢先加载补丁。</p>
</li>
<li><p>tinker差分算法：dexDiff , 新旧dex先排序，然后定义两个指针依次往下挪，如果old&gt;new，则一定是新增，如果old&lt;\new，则是删除，如果相等，则索引可能不同，需要记录索引的变化，最后如果相同的索引既有删除又有新增，则优化为replace操作。资源差分则采用BSDiff。</p>
</li>
<li><p>美团Robust，Instant Run方案，用代码插桩的方式，在每个方法中插入一段开关代码，如果需要修复，则走入if判断，执行补丁中的同名类的同名方法</p>
</li>
</ul>
<h3 id="插件化方案"><a href="#插件化方案" class="headerlink" title="插件化方案"></a>插件化方案</h3><p>插件化主要是加载新的功能模块，最主要的功能除了加载类，还需要加载资源和生命周期的管理。</p>
<ul>
<li>资源加载：通过反射AssetManager ，将资源所在路径添加到AssetManager的path中，然后创建一个Resource，hook住activity替换mResources实现资源的访问。具体分为两种：</li>
</ul>
<p>1.合并式：插件资源合并到主工程，插件和主工程可以直接访问资源，合并资源会造成资源id冲突，所以需要修改aapt源码，id格式为0xPPTTNNNN，在编译期修改高两位PP段，不同插件使用不同的PP段标识。<br>修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射，相当于一个索引。</p>
<p>2.独立式：插件只访问插件内部的资源，不能共享，也不会冲突。</p>
<ul>
<li><strong>生命周期的管理：</strong>没有在清单文件中注册过的Activity不能启动，现在的主流做法是预留各种启动模式的代理Activity占坑，然后通过hook住mInstrumentation对象，在启动插件Activity时替换intent为代理的Activity，从而绕过AMS的验证，系统以为是启动的代理Activity，然后真正启动时，需要还原原先的Intent，启动插件Activity，同时hook替换mResources，这样就实现了生命周期管理</li>
</ul>
<h3 id="VirtualApk原理"><a href="#VirtualApk原理" class="headerlink" title="VirtualApk原理"></a>VirtualApk原理</h3><p>如何加载插件类：（类加载机制）<br>插件创建ClassLoader，父类加载器是宿主的classloader，这样插件可以反射访问到宿主的类。</p>
<p>然后判断COMBINE_CLASSLOADER标记，如果COMBINE_CLASSLOADER为true，则会把dex插入到父类加载器的elements后边，使宿主可以访问插件的类。如果为false表示宿主与插件隔离，宿主不能访问插件。不论true或false，插件都可以访问宿主。</p>
<p>DroidPlugin是采用隔离模式，插件的classloader的父类加载器是BootClassLoader，所以相互都不能访问。</p>
<h3 id="如何加载资源："><a href="#如何加载资源：" class="headerlink" title="如何加载资源："></a>如何加载资源：</h3><ul>
<li><p>.COMBINE_CLASSLOADER为true：把插件资源添加到宿主Resources的AssetsManager的资源路径中去。<br>编译时过滤宿主和插件中的重复资源，然后修改R和资源表文件，让插件中只保留新的资源。<br>存在的问题：</p>
</li>
<li><p>.宿主和插件开发可能是并行的，过滤资源时候如果依赖的是1.0的宿主，在1.1中资源发生了变化，插件就会找不到资源，滴滴是让public.xml让宿主资源id不可变来实现。<br>如果宿主和插件有相同名字的资源，例如都有一个about字符串，由于资源过滤，插件的会被过滤掉。</p>
</li>
</ul>
<h3 id="activity的启动："><a href="#activity的启动：" class="headerlink" title="activity的启动："></a>activity的启动：</h3><p>hook系统instrumentation，判断如果启动的是插件的类，则通过预埋的activity绕过ams对activity的验证，然后在真正启动activity的时候，还原intent来启动目标类，这样目标类就有正常的生命周期了</p>
<h3 id="service的启动："><a href="#service的启动：" class="headerlink" title="service的启动："></a>service的启动：</h3><p>hook系统ActivityManager，创建一个动态代理来替换系统中的单例对象，实际上启动LocalService来代理目标服务的生命周期。</p>
<h3 id="广播："><a href="#广播：" class="headerlink" title="广播："></a>广播：</h3><p>解析清单文件，把注册的静态广播转换为动态广播。</p>
<p>启动activity时的问题</p>
<p>在创建插件的ClassLoader时，有一个COMBINE_CLASSLOADER标记用来设置是否要讲插件的dex插入到宿主的dex数组中，让宿主可以访问插件的类。COMBINE_CLASSLOADER标记为false时，宿主不能访问到插件类<br>源码instrumentation中handleMessage处理启动activity时，给intent的extras设置了宿主的类加载器，如果extra中有一个插件中才有的序列化对象，读取extra时反序列化会出错，就会抛出找不到类异常。到现在版本仍未解决。<br>解决方案：直接用一个新的intent包装原始的intent来替换，intent是parcelable的。</p>
<h3 id="RecyclerView缓存"><a href="#RecyclerView缓存" class="headerlink" title="RecyclerView缓存"></a>RecyclerView缓存</h3><p>1.mAttachedScrap和mChangedScrap，用于缓存屏幕内的ViewHolder，例如下拉刷新后，屏幕内的ViewHolder需要刷新数据<br>2.mCachedViews，移除屏幕之外的，默认缓存两个，因为接下来可能马上往回滑动，再次使用到<br>3.ViewCacheExtension，预留的一个缓存扩展，暂时没有用到<br>4.RecycledViewPool，缓存屏幕外的 ViewHolder，需要重新绑定数据</p>
<h3 id="AsyncTask原理和缺陷"><a href="#AsyncTask原理和缺陷" class="headerlink" title="AsyncTask原理和缺陷"></a>AsyncTask原理和缺陷</h3><p>实际是通过Handler+线程池实现，内部含有两个线程池，一个用于排队，一个用于真正执行任务</p>
<h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><ul>
<li>执行任务的线程池是个静态的全局线程池，最大线程数为128，如果任务队列满了，然后最大线程数也满了，再提交任务会出现崩溃；解决方案为自定义线程池</li>
<li>必须主线程初始化，内部handler获取主线程looper，否则不能正确切换到主线程。</li>
<li>结果丢失问题：如果activity重建，例如切横竖屏，因为持有的引用是重建之前的，新的Activity无法接收到结果。</li>
<li>内存泄漏，退出页面需要正确取消</li>
</ul>
<h3 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h3><p>卡顿优化</p>
<p>1.View本身绘制时间过长超过16ms造成掉帧，所以需要减少View嵌套层级，使用ViewStub和merge标签，优化过度绘制等</p>
<p>2.主线程执行耗时任务，合理使用线程，将耗时任务放到后台进行</p>
<p>3.内存抖动，会频繁触发GC，造成卡顿。使用内存分析工具优化内存使用，减少不必要对象的创建</p>
<h4 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h4><p>合理使用后台服务，合并网络请求，使用protobuf替换json进行服务端请求，cpu休眠锁等</p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>内存泄露优化（包括常见的内存泄漏、分析方法、LeakCanrary等）、使用优化的数据结构（ArrayMap和SparseArray），对频繁创建的对象使用对象池技术，减少不必要的内存开销，</p>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p>Application的attachBaseContext和onCreate，三方sdk采用线程池异步初始化，activity的onCreate中，设置布局的优化（xml的io操作、反射创建view的操作，通过异步inflater和自定义inflater.factory来优化）</p>
<p>1.延迟初始化非必要的库，拓展到异步启动器的设计和实现，有向无环图来解决库依赖的问题。<br>2.给闪屏页设置图片背景避免冷启动白屏，其实不能加快启动，只是避免白屏给用户的体验不佳</p>
<h3 id="apk大小优化"><a href="#apk大小优化" class="headerlink" title="apk大小优化"></a>apk大小优化</h3><p>1，开启混淆压缩代码<br>2，压缩和混淆资源，图片压缩采用webP格式，整理Raw、assets资源<br>3，减少非必要so库，目前主流的机型都是支持armeabi-v7a的，并且armeabi-v7a兼容armeabi<br>4，移除未使用的资源，如图标，字符串，字体等<br>5，一些小图像可以使用矢量图，大矢量图渲染时间很长，不适用<br>6，减少三方库使用，避免枚举的使用<br>7，动态下发一些资源，如换肤包，so，字体等</p>
<h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p>1.HttpDNS优化，传统DNS解析一般是用UDP的方式与DNS服务器交互，HttpDNS采用Http协议交互，绕过运营商的 LocalDNS 服务器，有效的防止了域名劫持，提高域名解析的效率<br>2.使用缓存，需要服务端支持，或者通过OkHttp拦截器添加统一的缓存策略<br>3.HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启keep-alive<br>4.数据压缩，gzip压缩，http2.0也支持header的压缩<br>5.根据网络质量来下载不同质量的图片</p>
<h3 id="View-inflate流程"><a href="#View-inflate流程" class="headerlink" title="View inflate流程"></a>View inflate流程</h3><p>1.先从resource中获取一个xml parser用于加载布局<br>2.读取layout文件，调用createViewFromTag创建View<br>3.tryCreateView中，依次判断有没有设置Factory2和Factory，如果有则调用它的createView来创建view<br>4.如果没有factory则调用自己的createView来创建，内部是使用反射创建对象<br>5.注意，Factory2继承Factory增加了一个创建view的方法，相当于是一个扩展，它们可以对view创建的过程进行拦截，在创建view的时候做一些事情，例如换肤功能就用到这里。</p>
<h3 id="换肤的原理"><a href="#换肤的原理" class="headerlink" title="换肤的原理"></a>换肤的原理</h3><p>1.制作皮肤包apk，只包含颜色、图片等，通过网络下载到sd卡；<br>2.通过反射构造皮肤包的AssetManager，再用此AssetManager创建Resource。<br>3.原apk和资源包中资源名称一样，提供一个资源映射的方法，通过原来的资源id找到资源名称，然后在皮肤包中查找皮肤资源具体的值；<br>4.通过自定义LayoutInflater传入自定义的Factory2拦截view的创建过程，查找到需要换肤的view和对应的可替换属性名(background、color、textcolor等)、属性值的类型（color\drawable\mipmap…）、属性值在原apk中的资源名(如color1)和资源的id，保存起来；<br>5.点击换肤时，遍历需要换肤的view集合，调用对应的方法（setColor等等）设置新的值。</p>
<h3 id="Android的startActivityForResult的实现为什么不使用回调。"><a href="#Android的startActivityForResult的实现为什么不使用回调。" class="headerlink" title="Android的startActivityForResult的实现为什么不使用回调。"></a>Android的startActivityForResult的实现为什么不使用回调。</h3><p>因为匿名内部类会持有外部类的引用，使用回调时，例如A启动B去获取result，由于某些原因原A已经被销毁了，当B设置结果返回A时，实际上A已经被系统重建，和原先的A不是同一个对象了，所以就不能正确的获取结果。</p>
<h3 id="如何跨app启动activity？"><a href="#如何跨app启动activity？" class="headerlink" title="如何跨app启动activity？"></a>如何跨app启动activity？</h3><p>1.shareUserId，设置同一个shareUserId的应用可以直接启动。<br>2.Exported 设置为true，向外部暴露activity，允许外部启动。<br>注意：为了安全需要添加自定义权限控制，注意被暴露的有权限的app需要先被安装，否则会获取不到权限。<br>会导致拒绝服务漏洞，例如：A启动B中的activity，往intent中添加一个序列化对象，这个对象只在A中有，B中没有这个类，如果在B中访问intent的extra，就会触发反序列化对象，由于找不到这个对象的类，造成B崩溃。处理方法：获取extra要捕获异常。<br>3.隐式启动activity，只要intentFilter匹配成功就可以启动。</p>
<h3 id="高性能日志采集"><a href="#高性能日志采集" class="headerlink" title="高性能日志采集"></a>高性能日志采集</h3><h5 id="传统直接读写文件的方式的缺点"><a href="#传统直接读写文件的方式的缺点" class="headerlink" title="传统直接读写文件的方式的缺点"></a>传统直接读写文件的方式的缺点</h5><p>读写文件的IO操作，需要两次拷贝，用户空间到内核空间，内核空间再到硬盘。为了避免频繁IO，采用缓存日志到内存，达到一定量时再统一写入文件，虽然避免了频繁IO，但是可能造成crash时日志丢失。多进程也无法保证写入顺序</p>
<h3 id="mmap方案："><a href="#mmap方案：" class="headerlink" title="mmap方案："></a>mmap方案：</h3><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。</p>
<h3 id="mmap的回写时机："><a href="#mmap的回写时机：" class="headerlink" title="mmap的回写时机："></a>mmap的回写时机：</h3><p>1.内存不足<br>2.进程退出<br>3.调用 msync 或者 munmap<br>4.不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</p>
<p>多进程写入映射同一个内存也会造成写入顺序无法保证，所以可以选择多进程映射不同的文件，每隔一段时间合并一次来解决</p>
<h3 id="性能优化工具："><a href="#性能优化工具：" class="headerlink" title="性能优化工具："></a>性能优化工具：</h3><p>查看方法执行时间：</p>
<h3 id="TraceView（影响性能）"><a href="#TraceView（影响性能）" class="headerlink" title="TraceView（影响性能）"></a>TraceView（影响性能）</h3><p>1.用Debug.startMethodTrace来打点，生成trace文件，然后用adb导出分析<br>2.使用profiler工具，选择cpu，输出trace文件</p>
<h3 id="Systrace（轻量级）"><a href="#Systrace（轻量级）" class="headerlink" title="Systrace（轻量级）"></a>Systrace（轻量级）</h3><p>1.TraceCompat.beginSection<br>2.使用python命令导出html，查看wall time和 cpu time</p>
<h3 id="MAT分析内存泄露："><a href="#MAT分析内存泄露：" class="headerlink" title="MAT分析内存泄露："></a>MAT分析内存泄露：</h3><p>profiler分析内存，手动触发gc，然后输出堆转储hporf文件，然后用mat分析引用链</p>
<h3 id="内存抖动："><a href="#内存抖动：" class="headerlink" title="内存抖动："></a>内存抖动：</h3><p>使用profiler工具排查</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2020/12/12/面试题001/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-分享常用的GoLang包工具" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/03/31/分享常用的GoLang包工具/">分享常用的GoLang包工具</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/03/31/分享常用的GoLang包工具/">
            <time datetime="2020-03-31T10:53:55.000Z" itemprop="datePublished">2020-03-31</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/go/">go</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/go/">go</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>包名                                                    链接地址                                                        备注<br>machinery异步队列                                        <a href="https://github.com/RichardKnop/machinery" target="_blank" rel="noopener">https://github.com/RichardKnop/machinery</a><br>Mqtt通信                                                <a href="https://github.com/eclipse/paho.mqtt.golang" target="_blank" rel="noopener">https://github.com/eclipse/paho.mqtt.golang</a>                    go文档<a href="http://www.eclipse.org/paho/clients/golang/" target="_blank" rel="noopener">http://www.eclipse.org/paho/clients/golang/</a><br>微信开发                                                <a href="https://github.com/chanxuehong/wechat" target="_blank" rel="noopener">https://github.com/chanxuehong/wechat</a><br>fasthttp包                                            <a href="https://github.com/valyala/fasthttp" target="_blank" rel="noopener">https://github.com/valyala/fasthttp</a><br>数据库操作包                                            <a href="https://github.com/gocraft/dbr" target="_blank" rel="noopener">https://github.com/gocraft/dbr</a><br>mysql db链式操作                                        <a href="https://github.com/gohouse/gorose" target="_blank" rel="noopener">https://github.com/gohouse/gorose</a><br>glide包管理工具                                        <a href="https://zhuanlan.zhihu.com/p/27994151" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27994151</a><br>文件配置包                                            <a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a><br>cli应用执行程序包                                        <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">https://github.com/spf13/cobra</a><br>redis包 命令式操作                                    <a href="https://github.com/garyburd/redigo/redis" target="_blank" rel="noopener">https://github.com/garyburd/redigo/redis</a><br>redis包 便捷操作                                        <a href="https://github.com/go-redis/redis" target="_blank" rel="noopener">https://github.com/go-redis/redis</a><br>日志包                                                <a href="https://www.jianshu.com/p/5fac8bed4505" target="_blank" rel="noopener">https://www.jianshu.com/p/5fac8bed4505</a><br>日志包                                                <a href="https://github.com/zbindenren/logrus_mail" target="_blank" rel="noopener">https://github.com/zbindenren/logrus_mail</a>                    邮件通知logrus的hooks<br>日志包                                               <a href="https://go.uber.org/zap" target="_blank" rel="noopener">https://go.uber.org/zap</a>     <a href="https://go.uber.org/zap/zapcore" target="_blank" rel="noopener">https://go.uber.org/zap/zapcore</a>     <a href="https://gopkg.in/natefinch/lumberjack.v2" target="_blank" rel="noopener">https://gopkg.in/natefinch/lumberjack.v2</a><br>gin Api文档包                                        <a href="https://github.com/swaggo/gin-swagger" target="_blank" rel="noopener">https://github.com/swaggo/gin-swagger</a><br>govalidator 参数验证器                                <a href="https://github.com/asaskevich/govalidator" target="_blank" rel="noopener">https://github.com/asaskevich/govalidator</a><br>json编解码库                                            <a href="https://github.com/json-iterator/go" target="_blank" rel="noopener">https://github.com/json-iterator/go</a><br>json web token                                        <a href="https://github.com/dgrijalva/jwt-go" target="_blank" rel="noopener">https://github.com/dgrijalva/jwt-go</a><br>类型转换                                                <a href="https://github.com/Unknwon/com" target="_blank" rel="noopener">https://github.com/Unknwon/com</a><br>优雅的重启Http服务                                    <a href="https://github.com/fvbock/endless" target="_blank" rel="noopener">https://github.com/fvbock/endless</a>                            目前只支持linux环境下使用，零时间重启。<br>权限控制                                                <a href="https://github.com/mikespook/gorbac" target="_blank" rel="noopener">https://github.com/mikespook/gorbac</a><br>WebSocket包                                            <a href="https://github.com/gorilla/websocket" target="_blank" rel="noopener">https://github.com/gorilla/websocket</a><br>定时任务包                                            <a href="https://github.com/robfig/cron" target="_blank" rel="noopener">https://github.com/robfig/cron</a><br>CloudXNS-DDNS                                        <a href="https://github.com/zwh8800/cloudxns-ddns" target="_blank" rel="noopener">https://github.com/zwh8800/cloudxns-ddns</a>                    动态域名客户端 docker 镜像<br>Restful和gprc相互转换                                    <a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">https://github.com/grpc-ecosystem/grpc-gateway</a>                example =&gt; <a href="https://github.com/go-up/go-example" target="_blank" rel="noopener">https://github.com/go-up/go-example</a><br>proto构建Go代码工具                                    <a href="https://github.com/tuneinc/truss" target="_blank" rel="noopener">https://github.com/tuneinc/truss</a>                            用于RPC协议文档生成<br>Api网关                                                <a href="https://github.com/fagongzi/gateway" target="_blank" rel="noopener">https://github.com/fagongzi/gateway</a><br>GO直播服务器                                            <a href="https://github.com/gwuhaolin/livego" target="_blank" rel="noopener">https://github.com/gwuhaolin/livego</a><br>RabbitMQ包                                            <a href="https://github.com/streadway/amqp" target="_blank" rel="noopener">https://github.com/streadway/amqp</a><br>gin中文文档                                            <a href="https://github.com/skybebe/gin-doc-cn" target="_blank" rel="noopener">https://github.com/skybebe/gin-doc-cn</a><br>http限流                                                <a href="https://github.com/didip/tollbooth" target="_blank" rel="noopener">https://github.com/didip/tollbooth</a><br>ORM包                                                <a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">https://github.com/go-sql-driver/mysql</a><br>TCP网络编程框架                                        <a href="https://github.com/leesper/holmes" target="_blank" rel="noopener">https://github.com/leesper/holmes</a>    <a href="https://github.com/leesper/tao" target="_blank" rel="noopener">https://github.com/leesper/tao</a><br>web框架                                                <a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">https://github.com/gin-gonic/gin</a><br>数据结构的可视化                                        <a href="https://github.com/Arafatk/DataViz" target="_blank" rel="noopener">https://github.com/Arafatk/DataViz</a><br>生成图                                                <a href="https://github.com/awalterschulze/gographviz" target="_blank" rel="noopener">https://github.com/awalterschulze/gographviz</a><br>与任何json交互                                        <a href="https://github.com/bitly/go-simplejson" target="_blank" rel="noopener">https://github.com/bitly/go-simplejson</a><br>现代文本索引Go库，类似于lucene。                        <a href="https://github.com/blevesearch/bleve" target="_blank" rel="noopener">https://github.com/blevesearch/bleve</a><br>Google 的一个开源图(Graph)数据库，                        <a href="https://github.com/cayleygraph/cayleygraph" target="_blank" rel="noopener">https://github.com/cayleygraph/cayleygraph</a>                     其灵感来自于 Freebase 和 Google 的 Knowledge Graph 背后的图数据库。<br>top工具                                                <a href="https://github.com/cjbassi/gotop" target="_blank" rel="noopener">https://github.com/cjbassi/gotop</a>                            golang重写的top工具，界面简洁、功能强大<br>缓存库                                                 <a href="https://github.com/coocood/freecache" target="_blank" rel="noopener">https://github.com/coocood/freecache</a>                        无额外的 GC 负荷。数百万对象的垃圾收集延迟仅在数百毫秒特性：<em> 可存储数以百万计条</em> 零垃圾收集负荷<em> 高并发而且线程安全的访问</em> 近乎 LRU 的算法* 严格限制内存使用<br>高可用的分布式key-value存储，                            <a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">https://github.com/coreos/etcd</a>    可以用于配置共享和服务发现；类似于zookeeper和consul；提供restful的http接口，使用简单；基于raft算法的强一致性、高可用的服务存储目录。<br>可视化工具                                            <a href="https://github.com/davecheney/httpstat" target="_blank" rel="noopener">https://github.com/davecheney/httpstat</a>                        可以测试http状态的可视化工具，通过这个工具可以看出来http响应信息。包括dns解析、tcp连接等信息,httpstat一共有golang版本和python版本。<br>调试工具                                                <a href="https://github.com/derekparker/delve" target="_blank" rel="noopener">https://github.com/derekparker/delve</a>                        Devle是一个非常棒的golang 调试工具，支持多种调试方式，直接运行调试，或者attach到一个正在运行中的golang程序，进行调试。<br>基本数据结构与算法的实现。                                <a href="https://github.com/floyernick/Data-Structures-and-Algorithms" target="_blank" rel="noopener">https://github.com/floyernick/Data-Structures-and-Algorithms</a><br>将ASCII图转换成手绘图。                                <a href="https://github.com/esimov/diagram" target="_blank" rel="noopener">https://github.com/esimov/diagram</a><br>模拟鼠标键盘事件、截屏等                                <a href="https://github.com/go-vgo/robotgo" target="_blank" rel="noopener">https://github.com/go-vgo/robotgo</a><br>packr 方便的潜入静态资源文件到golang 二进制文件中            <a href="https://github.com/gobuffalo/packr" target="_blank" rel="noopener">https://github.com/gobuffalo/packr</a><br>git服务器。                                            <a href="https://github.com/gogits/gogs" target="_blank" rel="noopener">https://github.com/gogits/gogs</a><br>从源码中提取json结构。                                 <a href="https://github.com/newhook/go-symbols" target="_blank" rel="noopener">https://github.com/newhook/go-symbols</a><br>go源码编写vim工具。                                    <a href="https://github.com/mdempsky/gocode" target="_blank" rel="noopener">https://github.com/mdempsky/gocode</a><br>消息队列。                                            <a href="https://github.com/nsqio/nsq" target="_blank" rel="noopener">https://github.com/nsqio/nsq</a><br>golang对于es操作库。                                     <a href="https://github.com/olivere/elastic" target="_blank" rel="noopener">https://github.com/olivere/elastic</a><br>支持类似于jQuery的功能。                                 <a href="https://github.com/PuerkitoBio/goquery" target="_blank" rel="noopener">https://github.com/PuerkitoBio/goquery</a><br>javascript解析器。                                     <a href="https://github.com/robertkrimen/otto" target="_blank" rel="noopener">https://github.com/robertkrimen/otto</a><br>从go源码中查找符号表信息。                                 <a href="https://github.com/rogpeppe/godef" target="_blank" rel="noopener">https://github.com/rogpeppe/godef</a><br>嵌入式数据库sqlite相关go操作。                             <a href="https://github.com/rqlite/rqlite" target="_blank" rel="noopener">https://github.com/rqlite/rqlite</a><br>从源码生成uml图，支持C++, Java, Python, Ruby and C#。     <a href="https://github.com/ruben2020/tags2uml" target="_blank" rel="noopener">https://github.com/ruben2020/tags2uml</a><br>Zookeeper Golang客户端                                <a href="https://github.com/samuel/go-zookeeper" target="_blank" rel="noopener">https://github.com/samuel/go-zookeeper</a><br>golang调试、测试使用，可以用来打印任何结构。                 <a href="https://github.com/sanity-io/litter" target="_blank" rel="noopener">https://github.com/sanity-io/litter</a><br>机器基本信息仪表盘。                                     <a href="https://github.com/senorprogrammer/wtf" target="_blank" rel="noopener">https://github.com/senorprogrammer/wtf</a><br>golang操作kafka库。                                     <a href="https://github.com/Shopify/sarama" target="_blank" rel="noopener">https://github.com/Shopify/sarama</a><br>日志框架。                                             <a href="https://github.com/Sirupsen/logrus" target="_blank" rel="noopener">https://github.com/Sirupsen/logrus</a><br>CLI命令行                                              <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">https://github.com/spf13/cobra</a>            Cobra既是一个用来创建强大的现代CLI命令行的golang库，也是一个生成程序应用和命令行文件的程序。<br>Hugo是由Go语言实现的静态网站生成器。                        <a href="https://github.com/spf13/hugo" target="_blank" rel="noopener">https://github.com/spf13/hugo</a>             简单、易用、高效、易扩展、快速部署。<br>配置文件操作库。                                         <a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a><br>多机器之间的同步工具。                                     <a href="https://github.com/syncthing/syncthing" target="_blank" rel="noopener">https://github.com/syncthing/syncthing</a><br>golang操作leveldb，一个本地数据库，高效kv。             <a href="https://github.com/syndtr/goleveldb" target="_blank" rel="noopener">https://github.com/syndtr/goleveldb</a>     Leveldb是一个google实现的非常高效的kv数据库，目前的版本1.2能够支持billion级别的数据量了。LevelDB 只是一个 C/C++ 编程语言的库, 不包含网络服务封装。<br>生成golang调用关系图。                                 <a href="https://github.com/TrueFurby/go-callvis" target="_blank" rel="noopener">https://github.com/TrueFurby/go-callvis</a><br>web框架。                                             <a href="https://github.com/urfave/negroni" target="_blank" rel="noopener">https://github.com/urfave/negroni</a><br>生成图表库。                                            <a href="https://github.com/vdobler/chart" target="_blank" rel="noopener">https://github.com/vdobler/chart</a><br>序列化反序列化工具，类似于pb。                             <a href="https://github.com/vmihailenco/msgpack" target="_blank" rel="noopener">https://github.com/vmihailenco/msgpack</a><br>生成图表库。                                             <a href="https://github.com/wcharczuk/go-chart" target="_blank" rel="noopener">https://github.com/wcharczuk/go-chart</a><br>access Kafka metadata in Zookeeper                     <a href="https://github.com/wvanbergen/kazoo-go" target="_blank" rel="noopener">https://github.com/wvanbergen/kazoo-go</a><br>补充返回值。                                            <a href="https://github.com/sqs/goreturns" target="_blank" rel="noopener">https://github.com/sqs/goreturns</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2020/03/31/分享常用的GoLang包工具/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/">Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/">
            <time datetime="2020-02-23T07:10:55.000Z" itemprop="datePublished">2020-02-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/linxu/">linxu</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/linxu/">linxu</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h3 id="安装之前检查下是否已经安装VNC安装之前检查下是否已经安装VNC"><a href="#安装之前检查下是否已经安装VNC安装之前检查下是否已经安装VNC" class="headerlink" title="安装之前检查下是否已经安装VNC安装之前检查下是否已经安装VNC"></a>安装之前检查下是否已经安装VNC安装之前检查下是否已经安装VNC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# rpm -q tigervnc tigervnc-server </span><br><span class="line">未安装软件包 tigervnc </span><br><span class="line">未安装软件包 tigervnc-server</span><br></pre></td></tr></table></figure>
<p>没有安装的话直接使用yum进行安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby  ~]# yum -y install tigervnc tigervnc-server</span><br><span class="line">......</span><br><span class="line">已安装:</span><br><span class="line">igervnc.x86_64 0:1.8.0-13.el7  tigervnc-server.x86_64 0:1.8.0-13.el7                   </span><br><span class="line"> </span><br><span class="line">作为依赖被安装:</span><br><span class="line">fltk.x86_64 0:1.3.4-1.el7  mesa-libGLU.x86_64 0:9.0.0-4.el7    tigervnc-icons.noarch 0:1.8.0-13.el7   </span><br><span class="line"> </span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure>
<p>复制配置模板并进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service</span><br><span class="line">[root@nearby ~]# vim /etc/systemd/system/vncserver@\:1.service</span><br></pre></td></tr></table></figure>
<p>将配置文件中的<user>改成对应的用户，我这里用root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Clean any existing files in /tmp/.X11-unix environment</span><br><span class="line">ExecStartPre=/bin/sh -c &apos;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&apos;</span><br><span class="line">ExecStart=/usr/sbin/runuser -l &lt;USER&gt; -c &quot;/usr/bin/vncserver %i&quot;</span><br><span class="line">PIDFile=/home/&lt;USER&gt;/.vnc/%H%i.pid</span><br><span class="line">ExecStop=/bin/sh -c &apos;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&apos;</span><br></pre></td></tr></table></figure></user></p>
<p>调整为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Clean any existing files in /tmp/.X11-unix environment</span><br><span class="line">ExecStartPre=/bin/sh -c &apos;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&apos;</span><br><span class="line">ExecStart=/usr/sbin/runuser -l root -c &quot;/usr/bin/vncserver %i&quot;</span><br><span class="line">PIDFile=/home/root/.vnc/%H%i.pid</span><br><span class="line">ExecStop=/bin/sh -c &apos;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&apos;</span><br></pre></td></tr></table></figure></p>
<p>要通知systemd重载此配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>现在为这个用户配置个密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# vncpasswd </span><br><span class="line">Password:</span><br><span class="line">Verify:</span><br><span class="line">Would you like to enter a view-only password (y/n)? y</span><br><span class="line">Password:</span><br><span class="line">Verify:</span><br><span class="line">[root@nearby ~]#</span><br></pre></td></tr></table></figure>
<p>设置开机服务自启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# systemctl enable vncserver@:1.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/vncserver@:1.service to /etc/systemd/system/vncserver@:1.service.</span><br></pre></td></tr></table></figure></p>
<p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# vncserver :1</span><br><span class="line">A VNC server is already running as :1</span><br><span class="line"> </span><br><span class="line">New &apos;nearby.jump:2 (root)&apos; desktop is nearby.jump:2</span><br><span class="line"> </span><br><span class="line">Starting applications specified in /root/.vnc/xstartup</span><br><span class="line">Log file is /root/.vnc/nearby.jump:2.log</span><br><span class="line"> </span><br><span class="line">[root@nearby ~]#</span><br></pre></td></tr></table></figure>
<h3 id="安Centos-7-安装GNOME桌面环境"><a href="#安Centos-7-安装GNOME桌面环境" class="headerlink" title="安Centos 7 安装GNOME桌面环境"></a>安Centos 7 安装GNOME桌面环境</h3><p>第1步：安装GNOME及相应桌面管理工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# yum groupinstall -y &quot;X Window System&quot; &quot;GNOME Desktop&quot;</span><br></pre></td></tr></table></figure></p>
<p>第2步：设置开机启动为GNOME<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# systemctl set-default graphical.target</span><br></pre></td></tr></table></figure></p>
<p>第3步：重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nearby ~]# reboot</span><br></pre></td></tr></table></figure></p>
<p>第4步：开启VNC服务需要用到的5900和5901端口。【此处阿里云服务器配置】<br><img src="/2020/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/../../../../images/aliyunanquanzu01.png" alt="Alt text"><br><img src="/2020/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/../../../../images/aliyunanquanzu02.png" alt="Alt text"></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2020/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-offce001" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/02/23/offce001/">Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/02/23/offce001/">
            <time datetime="2020-02-23T07:10:55.000Z" itemprop="datePublished">2020-02-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/linxu/">linxu</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/linxu/">linxu</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>View的绘制流程、Activity、Window、View的关系<br>Activity启动时创建Window、ViewRoot并建立关联，流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ActivityThread &#123;</span><br><span class="line">  // startActivity最终会调用到这里</span><br><span class="line">  fun handleLaunchActivity()&#123;</span><br><span class="line">	// 1. performLaunchActivity() 创建activity</span><br><span class="line">    // 2. activity.attach() 内部创建了PhoneWindow</span><br><span class="line">    // 3. activity.onCreate() -&gt; setContentView，实际调用window的对应方法，创建DecorView </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fun handleResumeActivity()&#123;</span><br><span class="line">    // 1. activity.onResume()</span><br><span class="line">    // 2. 获取activity的window对象，添加DecorView到WindowManagerGlobal中</span><br><span class="line">    // 3. WindowManagerGlobal.addView(DecorView)时，创建了ViewRootImpl，所有view绘制的工作都是</span><br><span class="line">    //		ViewRootImpl来调度，在这里才建立了ViewRootImpl和View的关联</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewRoot &#123;</span><br><span class="line">// ViewRoot添加view后，会执行ViewRoot.requestLayout</span><br><span class="line">// scheduleTraversals -&gt; 在消息队列中插入一个同步消息屏障,保证UI优先绘制 </span><br><span class="line">//  -&gt; 通过choreographer提交绘制任务，同时向底层请求sync信号，</span><br><span class="line">//  -&gt; 在下一次信号到来时JNI回调doTraversal，并移除屏障消息</span><br><span class="line">//  -&gt; doTraversal中调用了performMeasure、performLayout和performDraw进行测量、布局和绘制流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MeasureSpec是一个32位int值，高2位表示测量模式，后30位表示在该模式下的测量值，一个view的MeasureSpec由自己的LayoutParams和父View的MeasureSpec共同决定。测量过程实际是递归的测量子view后再设置自己的尺寸。</p>
<p>#onCreate、onResume中能否获取到View的宽高，为什么？<br>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View还没有测量完毕，那么获得的宽/高就是0。所以在onCreate、onStart、onResume中均无法正确得到某个View的宽高信息。<br>解决方式如下：</p>
<p>1.view.post(runnable)，注意这里handler.post(runnable)是不行的，View.post会先判断attachInfo是否为空，如果为空就放到一个等待执行的队列中，等待View被添加（dispatchAttachedToWindow）之后才执行，这时测量已经完毕了，如果不为空，表示View已经被添加，就调用attachInfo中的Handler来post任务，所以是一定能获取到的。注意api23以下和以上的逻辑不一样：</p>
<p>Api23以下：调用的ViewRootImpl.getRunQueue().post()，执行时机是doTraversa()中，这个方法又是在下一个同步信号来的时候调用的，参考屏幕刷新机制。</p>
<p>Api23以上：调用的是getRunQueue().post() ，它的执行时机是View被添加之后执行，如果View只是创建出来没有被添加，那将一直得不到执行。</p>
<p>2.使用ViewTreeObserver</p>
<p>#卡顿原理、屏幕刷新机制、卡顿监控</p>
<p>#卡顿的根本原因：view在16ms内不能完成绘制造成掉帧，常见造成掉帧的原因又有：</p>
<p>1.主线程有耗时操作（合理使用线程来执行耗时任务）<br>2.View本身太复杂、嵌套过多导致绘制超过16ms（优化View的层级、合理使用include、ViewStub标签）<br>3.内存抖动造成频繁GC，例如循环内部创建对象，onDraw中创建对象等。（优化内存泄漏、对一些需要频繁创建的对象采用对象池技术）</p>
<p>#屏幕刷新机制：</p>
<p>1.基于handler消息队列，如BlockCanary，handler分发消息前后都会打印日志，可以自定义Printer，计算Looper两次获取消息的时间差，如果时间太长就说明Handler处理时间过长，直接把堆栈信息打印出来，就可以定位到耗时代码<br>2.代码插桩，在方法的前后插入计时代码来监控执行时间，缺点是包增大，无法监控系统方法，并且需要过滤简单方法<br>3.循环插入空消息到消息队列，监控这个消息的处理时间，例如每隔1秒插入一条空消息，如果这条消息处理时间间隔大于一定时间，则认为发生了卡顿</p>
<p>#RxJava的原理<br>Rxjava每个操作符会生成一个新的Observable,同时持有上游事件源和下游Observer，最终在subscribeActual中实现自己的操作逻辑，并连接上下游。<br>Rxjava有点像观察者模式和责任链模式的结合，普通的观察者模式一般是被观察者通知多个观察者，而Rxjava则是被观察者通知第一个Obsever,接下来Observer依次通知下一个节点的Observer，形成一个“观察链”，将观察者模式进行了一种类似链式的变换，每个节点又会执行它不同的“职责”。</p>
<p>1.SubscribeOn节点在订阅的时候，将它的上游节点的subscribe操作，以runnable的形式交给调度器在执行，在io调度器就是一个线程池，他影响的是事件源的发射行为，如果多次subscribeOn相当后一次subscribeOn把上一次subscribeOn行为在线程池里执行了一次，最终就只有最上边的一个起作用；<br>2.observeOn会将它下游的Observer放到切换的线程中执行，因此observeOn影响的是它的下游，多次调用影响的是这次到下一次observeOn之间的代码；</p>
<p>#Rxjava中调度器<br>Schedulers.io()：无边界线程池作为支撑的一个Scheduler，线程可以无限增长，它适用于非CPU密集的I/O工作，比如访问文件系统、执行网络调用、访问数据库等<br>Schedulers.computation()：用于执行CPU密集的工作，比如处理大规模的数据集、图像处理等等。它由一个有界的线程池作为支撑，线程的最大数量就是可用的处理器数量<br>Schedulers.newThread()：这个Scheduler 每次都会创建一个全新的线程来完成一组工作<br><strong>Schedulers.single()：</strong>只有一个线程作为支撑，只能按照有序的方式执行任务<br><strong>Schedulers.from(Executor executor)</strong>我们可以使用它创建自定义的Scheduler<br>AndroidSchedulers.mainThread()：Android主线程调度器</p>
<p>#事件分发机制<br>事件传递的顺序：Activity-&gt;Window-&gt;DecorView</p>
<p>dispatchTouchEvent中：</p>
<p>1.判断是否需要拦截事件的标记intercepted<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 如果是down事件或者mFirstTouchTarget不为空</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123;</span><br><span class="line">  final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">  if (!disallowIntercept) &#123;</span><br><span class="line">    // 判断disallowIntercept标记</span><br><span class="line">    // 如果允许拦截则调用onInterceptTouchEvent</span><br><span class="line">    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 有disallowIntercept标记，不拦截</span><br><span class="line">    intercepted = false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 已有mFirstTouchTarget或者不是down时间，直接拦截</span><br><span class="line">  intercepted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.尝试分发事件：如果第一步不需要拦截，并且不是cancel状态，分发给子view</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">	// 遍历子view，判断坐标是否在view范围内并且view没有处于动画状态</span><br><span class="line">  // 满足条件则交给子view的dispatchTouchEvent来处理</span><br><span class="line">  // 如果子view处理了事件，则把子view赋值给mFirstTouchTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.再次分发事件：判断firstTouchTarget是否为空，如果为空表示没有子view处理事件，则间接的交给自己的onTouchEvent来处理，为空则直接交给firstTouchTarget处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mFirstTouchTarget == null) &#123;</span><br><span class="line">  // 没有子view处理事件，交给自己的onTouchEvent处理</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 直接交给mFirstTouchTarget处理后续事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<strong>onTouchListener ：</strong>如果有onTouchListener则优先交给onTouchListener处理，onTouchListener返回true则onTouchEvent将不会调用<br>5.cancel事件：父视图先不拦截，然后在 MOVE 事件中重新拦截，此时子 View 会接收到一个 CANCEL 事件，例如move出子view范围，或者scrollView中事件首先传递给子view，如果滑动则会被拦截。</p>
<p>#LeakCanary原理</p>
<p>首先java的四种引用，强、软、弱、虚四种引用，配合ReferenceQueue使用，在构造弱引用时传入ReferenceQueue，在垃圾回收之前，会将引用放入队列中，可以通过队列中是否有对象的引用来判断对象是否被回收；</p>
<p>具体就是在Application中注册ActivityLifecycleCallbacks监听activity的生命周期，在onDestory的时候，新建一个弱引用传入队列，在线程空闲的时候，会尝试清除队列的弱引用，如果成功则没有发生泄漏，如果失败，则尝试GC，GC之后再<br>次尝试清除弱引用，如果失败则发生了内存泄漏</p>
<p>Fragment也类似，在Activity创建时获取到FragmentManager注册一个fragmentLifecycleCallbacks，然后观察fragment；</p>
<p>#Retrofit原理<br>核心原理：在createService时，创建一个Api接口的动态代理，在loadServiceMethod方法先查找缓存，没有找到则解析Api接口，解析包括两部分，一个是方法上的注解，包括url、Header、请求参数等，第二个是方法的返回类型和参数类型，也就是CallAdapter和ConverAdapter</p>
<p>CallAdapter用于把结果适配成Rxjava、kotlin协程等返回类型</p>
<p>ConverAdapter用于把参数转化为json或者其他格式传输。</p>
<p>loadServiceMethod完毕后，实际上是把请求组装成一个OkHttpCall，用okhttp来进行具体的请求。</p>
<p>#OkHttp原理</p>
<p>优点：连接池技术复用连接，可以降低延迟，无缝支持gzip减少数据量，支持http2以及SPDY多路复用技术</p>
<p>责任链设计模式：用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕</p>
<p>#请求流程：<br>1.构建request<br>2.通过dispatcher执行请求，dispatcher内部包含三个队列：同步请求队列、异步等待队列和异步执行队列，对于同步请求，直接添加到同步请求队列执行，异步请求则添加到等待队列中，然后判断请求数是否大于最大请求数、以及同一个主机的最大请求数，如果可以执行，则提升到执行队列进行执行<br>3.无论是同步请求还是异步请求，最终都调用到getResponseWithInterceptorChain方法，核心就是拦截器链，包含了7大拦截器，分别负责不同的功能，每一个拦截器都可以自己处理请求，然后直接返回或者交给下一节点来处理。</p>
<pre><code>自定义拦截器
RetryAndFollowUpInterceptor：重试和重定向拦截器
BridgeInterceptor：用来设置一些必要的header
CacheInterceptor：处理缓存
ConnectInterceptor：负责建立服务器连接，优先从连接池中找到可用连接(soket连接是否可用，是否超时等，如不可用则会从连接池中移除)，否则打开一个新的连接
自定义网络拦截器
CallServerInterceptor：最后一个拦截器，用于真正发送网络请求，返回response
</code></pre><p>#为什么要组件化，怎么实现？了解的路由框架</p>
<p>痛点：在业务开发中，各个业务模块依赖关系复杂，耦合严重，造成app编译缓慢、不能并行开发、组件复用性不高的问题。通过组件化改造，可以对各个模块进行了业务隔离，使模块可以单独编译运行，降低耦合度，提高了开发和调试效率。</p>
<p>##组件拆分：</p>
<p>应用入口：一个空壳app，提供应用的启动页面</p>
<p>支撑业务组件：网络请求、图片加载等一些支撑服务</p>
<p>通用业务模块：例如支付、推送、地图等sdk，封装后对外提供调用接口</p>
<p>应用业务组件：具体的业务，可以提出来作为一个单独应用的功能模块，两两之间不互相依赖</p>
<p>##模块间的通信，需要引入路由框架，主流路由框架大概分为两种</p>
<p>ARouter：路由表+接口下沉的方式，在编译期间通过注解处理器扫描目标类，然后解析参数生成路由表，<br>模块服务通过接口下沉的方式，把接口定义在公共库中，具体实现类在业务模块中，在编译时通过扫描字节码发现实现类，然后通过ASM等字节码修改技术完成服务的注册；</p>
<p>CC：组件总线的方式，类似于EventBus发送消息一样，直接找到目标组件，发送一条指令执行对应操作，<br>通过gradle的Transform API:在编译时(dex/proguard之前)扫描当前要打包到apk中的所有类 ，然后通过ASM技术修改字节码，生成代码完成组件的注册；</p>
<p>#android优化的数据结构：SparseArray、ArrayMap</p>
<p>SparseArray的key只能为int，双列数组结构，优化了自动装箱的过程，并且会自动排序，查找采用二分查找，在数据量不大的情况下效率高</p>
<p>ArrayMap和SparseArray类似，但是key可以是对象，存储的时候存储通过key的hash值排序，也采用二分查找；</p>
<p>#进程间通信的方式</p>
<p>1.广播</p>
<p>2.Messenger，封装的Binder，可以执行简单的串行通信。</p>
<p>3.ContentProvider，适用于进程间的数据共享，可以进行操作权限的控制，如数据库的读写等。</p>
<p>4.Socket，适用于网络通信，用于传输原始的字节流，两次拷贝、效率低于binder</p>
<p>5.Binder，适用于复杂的进程通信，功能强大，CS架构，底层基于内存映射，只进行一次拷贝，所以效率高，可以验证通信的进程id，所以比socket更安全。</p>
<p>#AIDL和Binder机制</p>
<p>AIDL实际上是一套快速实现Binder通信的工具，通过定义AIDL接口，系统会自动生成一个类实现IInterface接口，内部包含Stub和Proxy两个内部类。服务端继承Stub提供服务。</p>
<p>##关键类和方法</p>
<p>Stub：服务端通过继承Stub，实现定义的接口来提供服务</p>
<p>Proxy：服务端对象的本地代理，客户端通过它来间接调用服务端接口的方法</p>
<p>asInterface：客户端调用，将binder对象转化为AIDL接口类型对象，如果和服务端在同一进程，返回Stub对象本身，否则返回Stub.proxy代理对象</p>
<p>asBinder：返回binder对象</p>
<p>onTransact：运行在服务端binder线程池，客户端请求时，远程请求会被系统封装后交给此方法处理</p>
<p>transact：运行在客户端，客户端发起请求时线程挂起，调用到服务端onTransact，等待其返回后才继续执行</p>
<p>#Binder机制</p>
<p>基于C/S架构，包括Server、Client、ServiceManager和Binder驱动，其中Binder驱动运行在内核空间，其他的运行在用户空间</p>
<p>ServiceManager负责服务管理，服务端向ServiceManager注册后，客户端可以向ServiceManager查询获取到目标服务的引用</p>
<p>Binder驱动：负责进程之间的Binder通信的建立，基于内存映射技术，传统的通信方式需要将数据从用户空间拷贝到内核空间，然后从内核空间拷贝到目标进程的用户空间，需要两次拷贝，Binder驱动可以建立用户空间内存和内核空间内存的一个映射，</p>
<p>只需要一次拷贝，非常高效。</p>
<p>#kotlin的扩展方法是怎么实现的，inline关键字的作用</p>
<p>扩展方法编译成java后，实际上是一个 public static的静态方法，传入了对象实例和参数<br>Inline关键字修饰的函数是内联函数，用于优化函数调用的压栈操作，相当于在编译期间把内联函数的代码拷贝到函数调用处，可以提升性能，但是增加了代码量</p>
<p>#Handler机制</p>
<p>##关键类：</p>
<p>Handler：用于发送消息和处理消息，发送消息就是将消息对象放入当前线程的MessageQueue中，然后Looper轮询到消息后交给自己处理，构造时需要传入Looper或者自动获取当前线程的Looper</p>
<p>Looper：轮询器，一个线程只能有一个Looper，用于从消息队列中轮询消息，然后交给对应的Handler处理</p>
<p>MessageQueue：消息队列，是一个阻塞队列，当没有消息是线程会被阻塞，等待有消息时唤醒线程</p>
<p>Message：消息对象，采用了对象池技术，可以避免对象的频繁创建开销</p>
<p>#消息的发送和轮询</p>
<p>发送消息：最终都会调用MessageQueue的enqueueMessage中，如果队列中没有消息或者消息的发送时间小于第一个消息，则直接放入队列头部，否则则根据时间插入到队列中的合适位置，同时会刷新needWeak标记，然后判断needWeak，如果需要唤醒，调用naviteWeak唤醒Looper。</p>
<p>获取消息：核心方法为MessageQueue的next，首先调用nativePollOnce，这个方法是一个native阻塞方法（通过监控文件描述符的io操作来实现），新消息放入队列时，会调用naviteWeak来唤醒。唤醒之后，如果是消息屏障就先处理异步消息，否则判断消息执行时间是否到达来返回消息或者进入下一个循环继续阻塞。</p>
<p>IdleHandler：在消息队列空闲的时候，会尝试执行IdleHandler的任务</p>
<p>消息屏障机制：当messageQueue取出屏障消息时，会开启循环，找到下一个异步消息执行，相当于阻塞了同步消息而优先执行异步消息，Android中所有UI绘制都是异步消息，可以保证UI绘制任务优先执行。</p>
<p>#postDelay怎么保证消息的顺序</p>
<p>发送消息时会对消息队列按执行时间进行排序，如果没有消息或者当前消息执行时间小于队列的第一条消息，则直接插入到表头，否则会插入到合适的位置，保证delay时间长的不会阻塞住时间短的。</p>
<p>#Activity启动流程<br>1.Luancher 进程通过binder向AMS发起startActivity请求<br>2.AMS收到请求， ActivityStarter解析flag，启动模式等，ActivityStack处理activity栈<br>3.然后AMS通过socket调用到Zygote，fork新的app进程<br>4.app进程创建后，再通过binder向AMS发起attachApplication请求<br>5.AMS通过binder调用发送scheduleLaunchActivity到app进程<br>6.APP进程的binder线程ApplicationThread接收到请求，通过handler发送LAUNCH_ACTIVITY消息到主线程<br>7.ActivityThread接收到消息，执行到handleLaunchActivity，开始Activity的生命周期<br><img src="/2020/02/23/offce001/../../../../images/a3aed8572f104535a3b0e679ea8c4cd9_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"><br>应用第一次启动时，zygote进程fork出应用进程后，AMS会保存一个ProcessRecord信息（包名+进程uid），下一次启动判断这个ProcessRecord已经存在的话，就不会再新建进程，这就属于应用内打开Activity的过程了</p>
<p>#APK打包流程<br><img src="/2020/02/23/offce001/../../../../images/4689f854f716495ea598a49d6ddac2b0_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"></p>
<p>1.打包资源文件，生成R.java文件<br>2.处理aidl文件，生成相应的Java文件<br>3.编译项目源代码，生成class文件（所有的Java代码，包括R.java和.aidl文件）<br>4.转换所有的class文件，生成classes.dex文件<br>5.打包生成APK文件<br>6.对APK文件进行签名<br>7.对签名后的APK文件进行对齐处理。对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用</p>
<p>#APK安装流程：</p>
<p>1.拷贝阶段：通过PMS通过handler发送一个安装消息，包含一些安装的参数，PackageHandler收到消息后通过隐式intent绑定到拷贝的service。检查apk安装路径，包的状态，然后拷贝至/data/app包名下<br>2.装载阶段：installPackageLI，PackageParser解析AndroidManifest文件，解析四大组件等信息<br>3.验证apk的签名信息<br>4.执行 dex 优化，实际为 dex2oat 操作，用来将 apk 中的 dex 文件转换为 oat 文件<br>5.安装apk，创建data目录，安装成功则更新权限等信息<br>6.发送成功广播，安装失败则删除安装包和缓存</p>
<p>#Android系统启动流程</p>
<p>1.开机加载BootLoader，加载Linux内核<br>2.启动Init进程<br>3.读取init.rc配置文件，启动几个关键进程，包括Zygote、ServiceManager、SurfaceFlinger和MediaServer<br>4.zygote进程启动java runntime，然后fork出sytem_server进程<br>5.sytem_server启动AMS、WMS、电源管理、等等系统服务，并通过Binder注册到ServiceManager。<br>6.启动Launcher显示桌面<br><img src="/2020/02/23/offce001/../../../../images/96bd5c17c1374385971a2ad840d964bc_tplv-k3u1fbpfcp-zoom-1.png" alt="Alt text"></p>
<p>#Webview的漏洞<br>1.4.2版本的addJavascriptInterface 造成的远程代码执行漏洞，当JS拿到Android这个对象后，就可以调用Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而执行任意代码</p>
<pre><code>4.2版本以上通过对调用的方法添加JavascriptInterface注解避免漏洞
4.2以下采用url拦截或者js弹窗拦截的方式进行交互，不能采用对象映射
</code></pre><p>2.密码明文存储<br>3.域控制不严问题，允许导出的WebActivity未关闭file协议，可以外部启动并加载恶意file协议的文件，从而访问私有文件，所以不需要使用file协议的，需要关闭</p>
<p>#Dalvik与ART的区别<br>1.Dalvik：即时编译，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，所以运行效率相对ART较低。由于不需要预编译，所以安装过程较快<br>2.ART ：应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高<br>3.ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%）<br>4.预编译也可以明显改善电池续航，从而减少了 CPU 的使用频率，降低了能耗。</p>
<p>#热修复和插件化原理<br>java类加载机制</p>
<p>双亲委托机制：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
<p>Java的类加载器分为：根加载器（加载java核心类）、扩展类加载器（加载jre扩展目录）、应用类加载器（加载classPath指定目录的类，自定义类加载器一般继承此加载器）</p>
<p>Android的类加载器：根加载器、BaseDexClassLoader、PathClassLoader（加载安装到系统的APK）、DexClassLoader（加载指定目录的dex和apk）</p>
<p>#热修复和插件化的区别</p>
<p>热修复：替换bug的类，需要把修复类抢先于bug类进行加载，让bug类得不到加载。通过反射修改DexClassLoader中DexPathList的dexElements数组，将需要加载的dex添加到数组前面。</p>
<p>插件化：运行未安装的插件apk的代码，不涉及到抢先加载，只需要将dex加载到dexElements中</p>
<p>#热修复的CLASS_ISPREVERIFIED问题</p>
<p>热修复是需要修复有bug的类，所以需要把dex放在数组的前端抢先加载补丁类，在虚拟机启动的时候，在verify选项被打开的时候，如果static方法、private方法、构造函数等，其中直接引用到的类都在同一个dex文件中，那么该类就会被打上CLASS_ISPREVERIFIED标志，且一旦类被打上CLASS_ISPREVERIFIED标志其他dex就不能再去替换这个类。<br>​        为了阻止类被打上CLASS_ISPREVERIFIED标志，先将一个预备好的hack.dex加入到dexElements的第一项，让后面的dex的所有类都引用hack.dex其中的一个类。</p>
<p>#常见热修复框架</p>
<p>Tinker实际上是类加载方案的升级，它增加了dex的差分算法，再将差分dex与apk中的classex.dex做合并，在运行bug类之前抢先加载补丁。</p>
<p>tinker差分算法：dexDiff , 新旧dex先排序，然后定义两个指针依次往下挪，如果old&gt;new，则一定是新增，如果old&lt;\new，则是删除，如果相等，则索引可能不同，需要记录索引的变化，最后如果相同的索引既有删除又有新增，则优化为replace操作。资源差分则采用BSDiff。</p>
<p>美团Robust，Instant Run方案，用代码插桩的方式，在每个方法中插入一段开关代码，如果需要修复，则走入if判断，执行补丁中的同名类的同名方法</p>
<p>#插件化方案</p>
<p>插件化主要是加载新的功能模块，最主要的功能除了加载类，还需要加载资源和生命周期的管理。</p>
<p>资源加载：通过反射AssetManager ，将资源所在路径添加到AssetManager的path中，然后创建一个Resource，hook住activity替换mResources实现资源的访问。具体分为两种：</p>
<p>1.合并式：插件资源合并到主工程，插件和主工程可以直接访问资源，合并资源会造成资源id冲突，所以需要修改aapt源码，id格式为0xPPTTNNNN，在编译期修改高两位PP段，不同插件使用不同的PP段标识。<br>修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射，相当于一个索引。</p>
<p>2.独立式：插件只访问插件内部的资源，不能共享，也不会冲突。</p>
<p><strong>生命周期的管理：</strong>没有在清单文件中注册过的Activity不能启动，现在的主流做法是预留各种启动模式的代理Activity占坑，然后通过hook住mInstrumentation对象，在启动插件Activity时替换intent为代理的Activity，从而绕过AMS的验证，系统以为是启动的代理Activity，然后真正启动时，需要还原原先的Intent，启动插件Activity，同时hook替换mResources，这样就实现了生命周期管理</p>
<p>#VirtualApk原理<br>如何加载插件类：（类加载机制）<br>插件创建ClassLoader，父类加载器是宿主的classloader，这样插件可以反射访问到宿主的类。</p>
<p>然后判断COMBINE_CLASSLOADER标记，如果COMBINE_CLASSLOADER为true，则会把dex插入到父类加载器的elements后边，使宿主可以访问插件的类。如果为false表示宿主与插件隔离，宿主不能访问插件。不论true或false，插件都可以访问宿主。</p>
<p>DroidPlugin是采用隔离模式，插件的classloader的父类加载器是BootClassLoader，所以相互都不能访问。</p>
<p>#如何加载资源：</p>
<p>1.COMBINE_CLASSLOADER为true：把插件资源添加到宿主Resources的AssetsManager的资源路径中去。<br>编译时过滤宿主和插件中的重复资源，然后修改R和资源表文件，让插件中只保留新的资源。<br>存在的问题：</p>
<p>2.宿主和插件开发可能是并行的，过滤资源时候如果依赖的是1.0的宿主，在1.1中资源发生了变化，插件就会找不到资源，滴滴是让public.xml让宿主资源id不可变来实现。<br>如果宿主和插件有相同名字的资源，例如都有一个about字符串，由于资源过滤，插件的会被过滤掉。</p>
<p>#activity的启动：</p>
<p>hook系统instrumentation，判断如果启动的是插件的类，则通过预埋的activity绕过ams对activity的验证，然后在真正启动activity的时候，还原intent来启动目标类，这样目标类就有正常的生命周期了</p>
<p>#service的启动：<br>hook系统ActivityManager，创建一个动态代理来替换系统中的单例对象，实际上启动LocalService来代理目标服务的生命周期。</p>
<p>#广播：</p>
<p>解析清单文件，把注册的静态广播转换为动态广播。</p>
<p>启动activity时的问题</p>
<p>在创建插件的ClassLoader时，有一个COMBINE_CLASSLOADER标记用来设置是否要讲插件的dex插入到宿主的dex数组中，让宿主可以访问插件的类。COMBINE_CLASSLOADER标记为false时，宿主不能访问到插件类<br>源码instrumentation中handleMessage处理启动activity时，给intent的extras设置了宿主的类加载器，如果extra中有一个插件中才有的序列化对象，读取extra时反序列化会出错，就会抛出找不到类异常。到现在版本仍未解决。<br>解决方案：直接用一个新的intent包装原始的intent来替换，intent是parcelable的。</p>
<p>#RecyclerView缓存</p>
<p>1.mAttachedScrap和mChangedScrap，用于缓存屏幕内的ViewHolder，例如下拉刷新后，屏幕内的ViewHolder需要刷新数据<br>2.mCachedViews，移除屏幕之外的，默认缓存两个，因为接下来可能马上往回滑动，再次使用到<br>3.ViewCacheExtension，预留的一个缓存扩展，暂时没有用到<br>4.RecycledViewPool，缓存屏幕外的 ViewHolder，需要重新绑定数据</p>
<p>#AsyncTask原理和缺陷</p>
<p>实际是通过Handler+线程池实现，内部含有两个线程池，一个用于排队，一个用于真正执行任务</p>
<p>#缺陷：<br>执行任务的线程池是个静态的全局线程池，最大线程数为128，如果任务队列满了，然后最大线程数也满了，再提交任务会出现崩溃；解决方案为自定义线程池<br>必须主线程初始化，内部handler获取主线程looper，否则不能正确切换到主线程。<br>结果丢失问题：如果activity重建，例如切横竖屏，因为持有的引用是重建之前的，新的Activity无法接收到结果。<br>内存泄漏，退出页面需要正确取消</p>
<p>#性能优化相关</p>
<p>卡顿优化</p>
<p>1.View本身绘制时间过长超过16ms造成掉帧，所以需要减少View嵌套层级，使用ViewStub和merge标签，优化过度绘制等</p>
<p>2.主线程执行耗时任务，合理使用线程，将耗时任务放到后台进行</p>
<p>3.内存抖动，会频繁触发GC，造成卡顿。使用内存分析工具优化内存使用，减少不必要对象的创建</p>
<p>#耗电优化</p>
<p>合理使用后台服务，合并网络请求，使用protobuf替换json进行服务端请求，cpu休眠锁等</p>
<p>#内存优化<br>内存泄露优化（包括常见的内存泄漏、分析方法、LeakCanrary等）、使用优化的数据结构（ArrayMap和SparseArray），对频繁创建的对象使用对象池技术，减少不必要的内存开销，</p>
<p>#启动优化</p>
<p>Application的attachBaseContext和onCreate，三方sdk采用线程池异步初始化，activity的onCreate中，设置布局的优化（xml的io操作、反射创建view的操作，通过异步inflater和自定义inflater.factory来优化）</p>
<p>1.延迟初始化非必要的库，拓展到异步启动器的设计和实现，有向无环图来解决库依赖的问题。<br>2.给闪屏页设置图片背景避免冷启动白屏，其实不能加快启动，只是避免白屏给用户的体验不佳</p>
<p>#apk大小优化<br>1，开启混淆压缩代码<br>2，压缩和混淆资源，图片压缩采用webP格式，整理Raw、assets资源<br>3，减少非必要so库，目前主流的机型都是支持armeabi-v7a的，并且armeabi-v7a兼容armeabi<br>4，移除未使用的资源，如图标，字符串，字体等<br>5，一些小图像可以使用矢量图，大矢量图渲染时间很长，不适用<br>6，减少三方库使用，避免枚举的使用<br>7，动态下发一些资源，如换肤包，so，字体等</p>
<p>#网络优化<br>1.HttpDNS优化，传统DNS解析一般是用UDP的方式与DNS服务器交互，HttpDNS采用Http协议交互，绕过运营商的 LocalDNS 服务器，有效的防止了域名劫持，提高域名解析的效率<br>2.使用缓存，需要服务端支持，或者通过OkHttp拦截器添加统一的缓存策略<br>3.HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启keep-alive<br>4.数据压缩，gzip压缩，http2.0也支持header的压缩<br>5.根据网络质量来下载不同质量的图片</p>
<p>#View inflate流程</p>
<p>1.先从resource中获取一个xml parser用于加载布局<br>2.读取layout文件，调用createViewFromTag创建View<br>3.tryCreateView中，依次判断有没有设置Factory2和Factory，如果有则调用它的createView来创建view<br>4.如果没有factory则调用自己的createView来创建，内部是使用反射创建对象<br>5.注意，Factory2继承Factory增加了一个创建view的方法，相当于是一个扩展，它们可以对view创建的过程进行拦截，在创建view的时候做一些事情，例如换肤功能就用到这里。</p>
<p>#换肤的原理<br>1.制作皮肤包apk，只包含颜色、图片等，通过网络下载到sd卡；<br>2.通过反射构造皮肤包的AssetManager，再用此AssetManager创建Resource。<br>3.原apk和资源包中资源名称一样，提供一个资源映射的方法，通过原来的资源id找到资源名称，然后在皮肤包中查找皮肤资源具体的值；<br>4.通过自定义LayoutInflater传入自定义的Factory2拦截view的创建过程，查找到需要换肤的view和对应的可替换属性名(background、color、textcolor等)、属性值的类型（color\drawable\mipmap…）、属性值在原apk中的资源名(如color1)和资源的id，保存起来；<br>5.点击换肤时，遍历需要换肤的view集合，调用对应的方法（setColor等等）设置新的值。</p>
<p>#Android的startActivityForResult的实现为什么不使用回调。<br>因为匿名内部类会持有外部类的引用，使用回调时，例如A启动B去获取result，由于某些原因原A已经被销毁了，当B设置结果返回A时，实际上A已经被系统重建，和原先的A不是同一个对象了，所以就不能正确的获取结果。</p>
<p>#如何跨app启动activity？<br>1.shareUserId，设置同一个shareUserId的应用可以直接启动。<br>2.Exported 设置为true，向外部暴露activity，允许外部启动。<br>注意：为了安全需要添加自定义权限控制，注意被暴露的有权限的app需要先被安装，否则会获取不到权限。<br>会导致拒绝服务漏洞，例如：A启动B中的activity，往intent中添加一个序列化对象，这个对象只在A中有，B中没有这个类，如果在B中访问intent的extra，就会触发反序列化对象，由于找不到这个对象的类，造成B崩溃。处理方法：获取extra要捕获异常。<br>3.隐式启动activity，只要intentFilter匹配成功就可以启动。</p>
<p>#高性能日志采集</p>
<p>##传统直接读写文件的方式的缺点<br>读写文件的IO操作，需要两次拷贝，用户空间到内核空间，内核空间再到硬盘。为了避免频繁IO，采用缓存日志到内存，达到一定量时再统一写入文件，虽然避免了频繁IO，但是可能造成crash时日志丢失。多进程也无法保证写入顺序</p>
<p>#mmap方案：<br>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。</p>
<p>#mmap的回写时机：</p>
<p>1.内存不足<br>2.进程退出<br>3.调用 msync 或者 munmap<br>4.不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</p>
<p>多进程写入映射同一个内存也会造成写入顺序无法保证，所以可以选择多进程映射不同的文件，每隔一段时间合并一次来解决</p>
<p>#性能优化工具：</p>
<p>查看方法执行时间：</p>
<p>#TraceView（影响性能）</p>
<p>1.用Debug.startMethodTrace来打点，生成trace文件，然后用adb导出分析<br>2.使用profiler工具，选择cpu，输出trace文件</p>
<p>#Systrace（轻量级）</p>
<p>1.TraceCompat.beginSection<br>2.使用python命令导出html，查看wall time和 cpu time</p>
<p>#MAT分析内存泄露：<br>profiler分析内存，手动触发gc，然后输出堆转储hporf文件，然后用mat分析引用链</p>
<p>#内存抖动：</p>
<p>使用profiler工具排查</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="http://b.nearby.ren/2020/02/23/offce001/#comments" class="article-comment-link">评论</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
    </nav>
</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/12/13/offce002/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/offce/">offce</a></p>
                            <p class="item-title"><a href="/2020/12/13/offce002/" class="title">offce 002</a></p>
                            <p class="item-date"><time datetime="2020-12-13T04:10:55.000Z" itemprop="datePublished">2020-12-13</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/12/12/面试题001/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/offce/">offce</a></p>
                            <p class="item-title"><a href="/2020/12/12/面试题001/" class="title">offce 001</a></p>
                            <p class="item-date"><time datetime="2020-12-12T03:10:55.000Z" itemprop="datePublished">2020-12-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/03/31/分享常用的GoLang包工具/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/go/">go</a></p>
                            <p class="item-title"><a href="/2020/03/31/分享常用的GoLang包工具/" class="title">分享常用的GoLang包工具</a></p>
                            <p class="item-date"><time datetime="2020-03-31T10:53:55.000Z" itemprop="datePublished">2020-03-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/linxu/">linxu</a></p>
                            <p class="item-title"><a href="/2020/02/23/Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程/" class="title">Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程</a></p>
                            <p class="item-date"><time datetime="2020-02-23T07:10:55.000Z" itemprop="datePublished">2020-02-23</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/02/23/offce001/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/linxu/">linxu</a></p>
                            <p class="item-title"><a href="/2020/02/23/offce001/" class="title">Centos 7 安装GNOME桌面环境与安装 VNC 使用图形界面远程</a></p>
                            <p class="item-date"><time datetime="2020-02-23T07:10:55.000Z" itemprop="datePublished">2020-02-23</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/RecyclerView/">RecyclerView</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android-studio/">android studio</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/apk/">apk</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/dagger2/">dagger2</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">gradle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linxu/">linxu</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mvp/">mvp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/offce/">offce</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/resume/">resume</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rxjava/">rxjava</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tinker/">tinker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vuforia/">vuforia</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/延迟搜索/">延迟搜索</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/文字/">文字</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/">软件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/适配/">适配</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">十月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a><span class="archive-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac-Linux/">Mac/Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">31</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-studio/">android studio</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/">bug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dagger2/">dagger2</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">gradle</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h5/">h5</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https/">https</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linxu/">linxu</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mvp/">mvp</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/offce/">offce</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/resume/">resume</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxandroid/">rxandroid</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjava/">rxjava</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/service/">service</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/">springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuforia/">vuforia</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/延迟/">延迟</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文字/">文字</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/歌曲/">歌曲</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/直播/">直播</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔录/">笔录</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件名词/">软件名词</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Mac-Linux/" style="font-size: 10px;">Mac/Linux</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/android-studio/" style="font-size: 10px;">android studio</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/dagger2/" style="font-size: 12.5px;">dagger2</a> <a href="/tags/git/" style="font-size: 17.5px;">git</a> <a href="/tags/glide/" style="font-size: 15px;">glide</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/gradle/" style="font-size: 12.5px;">gradle</a> <a href="/tags/h5/" style="font-size: 10px;">h5</a> <a href="/tags/hexo/" style="font-size: 12.5px;">hexo</a> <a href="/tags/https/" style="font-size: 12.5px;">https</a> <a href="/tags/ios/" style="font-size: 12.5px;">ios</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/linxu/" style="font-size: 15px;">linxu</a> <a href="/tags/mac/" style="font-size: 12.5px;">mac</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mvp/" style="font-size: 15px;">mvp</a> <a href="/tags/offce/" style="font-size: 12.5px;">offce</a> <a href="/tags/resume/" style="font-size: 15px;">resume</a> <a href="/tags/rxandroid/" style="font-size: 12.5px;">rxandroid</a> <a href="/tags/rxjava/" style="font-size: 12.5px;">rxjava</a> <a href="/tags/service/" style="font-size: 10px;">service</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/view/" style="font-size: 15px;">view</a> <a href="/tags/vuforia/" style="font-size: 10px;">vuforia</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/延迟/" style="font-size: 10px;">延迟</a> <a href="/tags/文字/" style="font-size: 12.5px;">文字</a> <a href="/tags/歌曲/" style="font-size: 12.5px;">歌曲</a> <a href="/tags/直播/" style="font-size: 10px;">直播</a> <a href="/tags/笔录/" style="font-size: 15px;">笔录</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/软件名词/" style="font-size: 10px;">软件名词</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 阿荣<br>
            <!-- <a href="http://github.com/ppoffice">ppoffice</a>     
            主题 - <a href="http://hexo.io/" target="_blank">Hexo</a> -->  
             <a href="#" target="_blank">人生如逆旅  &phi; 我亦是行人 </a>
             <div class="copyright" style="margin-top: 10px;">
 			ICP备案号： <a href="http://www.miitbeian.gov.cn" target="_blank">粤ICP备16067940号</a><br>
		</div>	
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2119666"></script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>